<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code Documentation on CIRCT</title><link>https://circt.llvm.org/docs/</link><description>Recent content in Code Documentation on CIRCT</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 Nov 2019 15:26:15 +0000</lastBuildDate><atom:link href="https://circt.llvm.org/docs/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://circt.llvm.org/docs/SVPasses/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/SVPasses/</guid><description>-sv-always-fusion: Combine AlwaysFF blocks with the same predicate This pass finds all AlwaysFF operations with the same condition, and combines them in to a single operation. For example:
// Input rtl.module() { sv.alwaysff(posedge %clock) { sv.passign %counter, %1 : i8 } sv.alwaysff(posedge %clock) { sv.passign %param, %2 : i16 } } // Output rtl.module() { sv.alwaysff(posedge %clock) { sv.passign %counter, %1 : i8 sv.passign %param, %2 : i16 } }</description></item><item><title>CIRCT Charter</title><link>https://circt.llvm.org/docs/Charter/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Charter/</guid><description>Abstract Recent trends in computer architecture have resulted in two core problems. Firstly, how do we design complex, heterogenous systems-on-chip mixing general purpose and specialized components? Secondly, how do we program them? We believe that design tools that represent and manipulate a wide variety of abstractions are central to solving these problems. This projects is focused on using LLVM/MLIR to express these abstractions and to build useable open-source flows based on those abstractions to solve the design problems of the next decade.</description></item><item><title>FIRRTL Dialect Rationale</title><link>https://circt.llvm.org/docs/RationaleFIRRTL/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleFIRRTL/</guid><description>This document describes various design points of the FIRRTL dialect, why it is the way it is, and current status and progress. This follows in the spirit of other MLIR Rationale docs .
Introduction The FIRRTL project is an existing open source compiler infrastructure used by the Chisel framework to lower &amp;ldquo;.fir&amp;rdquo; files to Verilog. It provides a number of useful compiler passes and infrastructure that allows the development of domain specific passes.</description></item><item><title>Passes</title><link>https://circt.llvm.org/docs/Passes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Passes/</guid><description>This document describes the available CIRCT passes and their contracts.
Transformations Passes -llhd-early-code-motion: Move side-effect-free instructions and llhd.prb up in the CFG -llhd-function-elimination: Deletes all functions. -llhd-memory-to-block-argument: Promote memory to block arguments. -llhd-process-lowering: Lowers LLHD Processes to Entities. Conversion Passes -convert-firrtl-to-llhd: Convert FIRRTL to LLHD -convert-rtl-to-llhd: Convert RTL to LLHD -convert-llhd-to-llvm: Convert LLHD to LLVM -lower-firrtl-to-rtl: Lower FIRRTL to RTL -lower-firrtl-to-rtl-module: Lower FIRRTL to RTL Modules firrtl Dialect Passes -firrtl-lower-types: Lower FIRRTL types to ground types sv Dialect Passes Transformations Passes -llhd-early-code-motion: Move side-effect-free instructions and llhd.</description></item><item><title>RTL and SV Dialect Rationale</title><link>https://circt.llvm.org/docs/RationaleRTL-SV/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleRTL-SV/</guid><description>This document describes various design points of the RTL and SV dialects, why they are the way they are, and current status. This follows in the spirit of other MLIR Rationale docs .
Introduction SystemVerilog is an industry standard language for hardware design and verification, is known by a large number of engineers who write it directly, and is an important interchange format between EDA tools. However, while it is ubiquitous, SystemVerilog is not easy to generate or transform.</description></item></channel></rss>