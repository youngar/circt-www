<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'rtl' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.64.1"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/RTL/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://circt.llvm.org/js/bundle.js></script><script type=text/javascript src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'rtl' Dialect</h1><p>Types and operations for rtl dialect
This dialect defines the <code>rtl</code> dialect, which is intended to be a generic
representation of RTL outside of a particular use-case.</p><p><nav id=TableOfContents><ul><li><a href=#type-constraint-definition>Type constraint definition</a><ul><li><a href=#fixed-sized-array>fixed-sized array</a></li><li><a href=#inout-type>inout type</a></li><li><a href=#rtl-struct-type>RTL struct type</a></li><li><a href=#systemverilog-unpacked-fixed-sized-array>SystemVerilog &lsquo;unpacked&rsquo; fixed-sized array</a></li></ul></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#rtladd-circtrtladdop>rtl.add (::circt::rtl::AddOp)</a></li><li><a href=#rtland-circtrtlandop>rtl.and (::circt::rtl::AndOp)</a></li><li><a href=#rtlandr-circtrtlandrop>rtl.andr (::circt::rtl::AndROp)</a></li><li><a href=#rtlarray_create-circtrtlarraycreateop>rtl.array_create (::circt::rtl::ArrayCreateOp)</a></li><li><a href=#rtlarray_get-circtrtlarraygetop>rtl.array_get (::circt::rtl::ArrayGetOp)</a></li><li><a href=#rtlarray_slice-circtrtlarraysliceop>rtl.array_slice (::circt::rtl::ArraySliceOp)</a></li><li><a href=#rtlbitcast-circtrtlbitcastop>rtl.bitcast (::circt::rtl::BitcastOp)</a></li><li><a href=#integer-bit-vectors>Integer bit vectors</a></li><li><a href=#arrays>Arrays</a></li><li><a href=#structs>Structs</a></li><li><a href=#example-figure>Example figure</a></li><li><a href=#rtlconcat-circtrtlconcatop>rtl.concat (::circt::rtl::ConcatOp)</a></li><li><a href=#rtlconstant-circtrtlconstantop>rtl.constant (::circt::rtl::ConstantOp)</a></li><li><a href=#rtldivs-circtrtldivsop>rtl.divs (::circt::rtl::DivSOp)</a></li><li><a href=#rtldivu-circtrtldivuop>rtl.divu (::circt::rtl::DivUOp)</a></li><li><a href=#rtlextract-circtrtlextractop>rtl.extract (::circt::rtl::ExtractOp)</a></li><li><a href=#rtlicmp-circtrtlicmpop>rtl.icmp (::circt::rtl::ICmpOp)</a></li><li><a href=#rtlinstance-circtrtlinstanceop>rtl.instance (::circt::rtl::InstanceOp)</a></li><li><a href=#rtlmerge-circtrtlmergeop>rtl.merge (::circt::rtl::MergeOp)</a></li><li><a href=#rtlmods-circtrtlmodsop>rtl.mods (::circt::rtl::ModSOp)</a></li><li><a href=#rtlmodu-circtrtlmoduop>rtl.modu (::circt::rtl::ModUOp)</a></li><li><a href=#rtlmul-circtrtlmulop>rtl.mul (::circt::rtl::MulOp)</a></li><li><a href=#rtlmux-circtrtlmuxop>rtl.mux (::circt::rtl::MuxOp)</a></li><li><a href=#rtlor-circtrtlorop>rtl.or (::circt::rtl::OrOp)</a></li><li><a href=#rtlorr-circtrtlorrop>rtl.orr (::circt::rtl::OrROp)</a></li><li><a href=#rtloutput-circtrtloutputop>rtl.output (::circt::rtl::OutputOp)</a></li><li><a href=#rtlexternmodule-circtrtlrtlexternmoduleop>rtl.externmodule (::circt::rtl::RTLExternModuleOp)</a></li><li><a href=#rtlmodule-circtrtlrtlmoduleop>rtl.module (::circt::rtl::RTLModuleOp)</a></li><li><a href=#rtlsext-circtrtlsextop>rtl.sext (::circt::rtl::SExtOp)</a></li><li><a href=#rtlshl-circtrtlshlop>rtl.shl (::circt::rtl::ShlOp)</a></li><li><a href=#rtlshrs-circtrtlshrsop>rtl.shrs (::circt::rtl::ShrSOp)</a></li><li><a href=#rtlshru-circtrtlshruop>rtl.shru (::circt::rtl::ShrUOp)</a></li><li><a href=#rtlstruct_create-circtrtlstructcreateop>rtl.struct_create (::circt::rtl::StructCreateOp)</a></li><li><a href=#rtlstruct_explode-circtrtlstructexplodeop>rtl.struct_explode (::circt::rtl::StructExplodeOp)</a></li><li><a href=#rtlstruct_extract-circtrtlstructextractop>rtl.struct_extract (::circt::rtl::StructExtractOp)</a></li><li><a href=#rtlstruct_inject-circtrtlstructinjectop>rtl.struct_inject (::circt::rtl::StructInjectOp)</a></li><li><a href=#rtlsub-circtrtlsubop>rtl.sub (::circt::rtl::SubOp)</a></li><li><a href=#rtlxor-circtrtlxorop>rtl.xor (::circt::rtl::XorOp)</a></li><li><a href=#rtlxorr-circtrtlxorrop>rtl.xorr (::circt::rtl::XorROp)</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#arraytype-arraytype>ArrayType (ArrayType)</a></li><li><a href=#inouttype-inouttype>InOutType (InOutType)</a></li><li><a href=#structtype-structtype>StructType (StructType)</a></li><li><a href=#unpackedarraytype-unpackedarraytype>UnpackedArrayType (UnpackedArrayType)</a></li></ul></li></ul></nav><h2 id=type-constraint-definition>Type constraint definition&nbsp;<a class=headline-hash href=#type-constraint-definition>¶</a></h2><h3 id=fixed-sized-array>fixed-sized array&nbsp;<a class=headline-hash href=#fixed-sized-array>¶</a></h3><p>Fixed sized RTL arrays are roughly similar to C arrays. On the wire (vs.
in a memory), arrays are always packed. Memory layout is not defined as
it does not need to be since in silicon there is not implicit memory
sharing.</p><h3 id=inout-type>inout type&nbsp;<a class=headline-hash href=#inout-type>¶</a></h3><p>InOut type is used for model operations and values that have &ldquo;connection&rdquo;
semantics, instead of typical dataflow behavior. This is used for wires
and inout ports in Verilog.</p><h3 id=rtl-struct-type>RTL struct type&nbsp;<a class=headline-hash href=#rtl-struct-type>¶</a></h3><p>Represents a structure of name, value pairs.
!rtl.struct&lt;fieldName1: Type1, fieldName2: Type2></p><h3 id=systemverilog-unpacked-fixed-sized-array>SystemVerilog &lsquo;unpacked&rsquo; fixed-sized array&nbsp;<a class=headline-hash href=#systemverilog-unpacked-fixed-sized-array>¶</a></h3><p>Unpacked arrays are a more flexible array representation than packed arrays,
and are typically used to model memories. See SystemVerilog Spec 7.4.2.</p><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=rtladd-circtrtladdop><code>rtl.add</code> (::circt::rtl::AddOp)&nbsp;<a class=headline-hash href=#rtladd-circtrtladdop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `rtl.add` $inputs attr-dict `:` type($result)
</code></pre><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtland-circtrtlandop><code>rtl.and</code> (::circt::rtl::AndOp)&nbsp;<a class=headline-hash href=#rtland-circtrtlandop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `rtl.and` $inputs attr-dict `:` type($result)
</code></pre><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtlandr-circtrtlandrop><code>rtl.andr</code> (::circt::rtl::AndROp)&nbsp;<a class=headline-hash href=#rtlandr-circtrtlandrop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `rtl.andr` $input attr-dict `:` type($input)
</code></pre><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=rtlarray_create-circtrtlarraycreateop><code>rtl.array_create</code> (::circt::rtl::ArrayCreateOp)&nbsp;<a class=headline-hash href=#rtlarray_create-circtrtlarraycreateop>¶</a></h3><p>Create an array from values</p><p>Creates an array from a variable set of values. One or more values must be
listed.</p><pre><code>// %a, %b, %c are all i4
%array = rtl.array_create %a, %b, %c : (i4)
</code></pre><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>a type without inout</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>fixed-sized array</td></tr></tbody></table><h3 id=rtlarray_get-circtrtlarraygetop><code>rtl.array_get</code> (::circt::rtl::ArrayGetOp)&nbsp;<a class=headline-hash href=#rtlarray_get-circtrtlarraygetop>¶</a></h3><p>Get the value in an array at the specified index</p><p>Syntax:</p><pre><code>operation ::= `rtl.array_get` $input`[`$index`]` attr-dict `:` type($input)
</code></pre><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>fixed-sized array</td></tr><tr><td align=center><code>index</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a type without inout</td></tr></tbody></table><h3 id=rtlarray_slice-circtrtlarraysliceop><code>rtl.array_slice</code> (::circt::rtl::ArraySliceOp)&nbsp;<a class=headline-hash href=#rtlarray_slice-circtrtlarraysliceop>¶</a></h3><p>Get a range of values from an array</p><p>Syntax:</p><pre><code>operation ::= `rtl.array_slice` $input `at` $lowIndex attr-dict `:`
              `(` custom&lt;SliceTypes&gt;(type($input), type($lowIndex)) `)` `-&gt;` type($dst)
</code></pre><p>Extracts a sub-range from an array. The range is from <code>lowIndex</code> to
<code>lowIndex</code> + the number of elements in the return type, non-inclusive on
the high end. For instance,</p><pre><code>// Slices 16 elements starting at '%offset'.
%subArray = rtl.slice %largerArray at %offset :
    (!rtl.array&lt;1024xi8&gt;) -&gt; !rtl.array&lt;16xi8&gt;
</code></pre><p>Would translate to the following SystemVerilog:</p><pre><code>logic [7:0][15:0] subArray = largerArray[offset +: 16];
</code></pre><p>Width of &lsquo;idx&rsquo; is defined to be the precise number of bits required to
index the &lsquo;input&rsquo; array. More precisely: for an input array of size M,
the width of &lsquo;idx&rsquo; is ceil(log2(M)). Lower and upper bound indexes which
are larger than the size of the &lsquo;input&rsquo; array results in undefined
behavior.</p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>fixed-sized array</td></tr><tr><td align=center><code>lowIndex</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dst</code></td><td>fixed-sized array</td></tr></tbody></table><h3 id=rtlbitcast-circtrtlbitcastop><code>rtl.bitcast</code> (::circt::rtl::BitcastOp)&nbsp;<a class=headline-hash href=#rtlbitcast-circtrtlbitcastop>¶</a></h3><pre><code>Reinterpret one value to another value of the same size and
potentially different type.
</code></pre><p>Syntax:</p><pre><code>operation ::= `rtl.bitcast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>The bitcast operation represents a bitwise reinerpretation (cast) of a
value. This always synthesizes away in hardware, though if may or may not
be syntactically represented in lowering or export language.</p><p>Since bitcasting requires information on the bitwise layout of the types
on which it operates, we discuss that here.</p><h3 id=integer-bit-vectors>Integer bit vectors&nbsp;<a class=headline-hash href=#integer-bit-vectors>¶</a></h3><p>MLIR&rsquo;s <code>IntegerType</code> with <code>Signless</code> semantics are used to represent bit
vectors. They are never padded or aligned.</p><h3 id=arrays>Arrays&nbsp;<a class=headline-hash href=#arrays>¶</a></h3><p>The RTL dialect defines a custom <code>ArrayType</code>.</p><ul><li><strong>Bit layout</strong>: High index of array starts at the MSB. Array&rsquo;s 0th
element&rsquo;s LSB located at array LSB.</li><li><strong>Padding between elements</strong>: None</li><li><strong>Alignment of elements</strong>: None</li></ul><h3 id=structs>Structs&nbsp;<a class=headline-hash href=#structs>¶</a></h3><p>The RTL dialect defines a custom <code>StructType</code>.</p><ul><li><strong>Bit layout</strong>: The first listed member&rsquo;s MSB corresponds to the
struct&rsquo;s MSB. The last member in the list shares its LSB with the
struct.</li><li><strong>Padding between elements</strong>: None</li><li><strong>Alignment of elements</strong>: None</li></ul><h3 id=example-figure>Example figure&nbsp;<a class=headline-hash href=#example-figure>¶</a></h3><pre><code>15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 
-------------------------------------------------
| MSB                                       LSB | 16 bit integer vector
-------------------------------------------------
                         | MSB              LSB | 8 bit integer vector
-------------------------------------------------
| MSB      [1]       LSB | MSB     [0]      LSB | 2 element array of 8 bit integer vectors
-------------------------------------------------

      13 12 11 10  9  8  7  6  5  4  3  2  1  0 
                            ---------------------
                            | MSB           LSB | 7 bit integer vector
      -------------------------------------------
      | MSB     [1]     LSB | MSB    [0]    LSB | 2 element array of 7 bit integer vectors
      -------------------------------------------
      | MSB a LSB | MSB b[1] LSB | MSB b[0] LSB | struct
      -------------------------------------------  a: 4 bit integral
                                                   b: 2 element array of 5 bit integer vectors
</code></pre><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>Type wherein the bitwidth in hardware is known</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>Type wherein the bitwidth in hardware is known</td></tr></tbody></table><h3 id=rtlconcat-circtrtlconcatop><code>rtl.concat</code> (::circt::rtl::ConcatOp)&nbsp;<a class=headline-hash href=#rtlconcat-circtrtlconcatop>¶</a></h3><p>Concatenate a variadic list of operands together.</p><p>Syntax:</p><pre><code>operation ::= `rtl.concat` $inputs attr-dict `:` functional-type($inputs, results)
</code></pre><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtlconstant-circtrtlconstantop><code>rtl.constant</code> (::circt::rtl::ConstantOp)&nbsp;<a class=headline-hash href=#rtlconstant-circtrtlconstantop>¶</a></h3><p>Produce a constant value</p><p>Syntax:</p><pre><code>operation ::= `rtl.constant` `(` $value `)` attr-dict `:` type($result)
</code></pre><p>The constant operation produces a constant value of standard integer type
without a sign.</p><pre><code>  %result = rtl.constant 42 : t1
</code></pre><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td align=center>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtldivs-circtrtldivsop><code>rtl.divs</code> (::circt::rtl::DivSOp)&nbsp;<a class=headline-hash href=#rtldivs-circtrtldivsop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `rtl.divs` $lhs `,` $rhs  attr-dict `:` type($result)
</code></pre><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>an integer bitvector of one or more bits</td></tr><tr><td align=center><code>rhs</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtldivu-circtrtldivuop><code>rtl.divu</code> (::circt::rtl::DivUOp)&nbsp;<a class=headline-hash href=#rtldivu-circtrtldivuop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `rtl.divu` $lhs `,` $rhs  attr-dict `:` type($result)
</code></pre><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>an integer bitvector of one or more bits</td></tr><tr><td align=center><code>rhs</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtlextract-circtrtlextractop><code>rtl.extract</code> (::circt::rtl::ExtractOp)&nbsp;<a class=headline-hash href=#rtlextract-circtrtlextractop>¶</a></h3><p>Extract a range of bits into a smaller value, lowBit specifies the lowest bit included.</p><p>Syntax:</p><pre><code>operation ::= `rtl.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
</code></pre><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lowBit</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtlicmp-circtrtlicmpop><code>rtl.icmp</code> (::circt::rtl::ICmpOp)&nbsp;<a class=headline-hash href=#rtlicmp-circtrtlicmpop>¶</a></h3><p>Compare two integer values</p><p>Syntax:</p><pre><code>operation ::= `rtl.icmp` $predicate $lhs `,` $rhs  attr-dict `:` type($lhs)
</code></pre><p>This operation compares two integers using a predicate. If the predicate is
true, returns 1, otherwise returns 0. This operation always returns a one
bit wide result.</p><pre><code>    %r = rtl.icmp eq %a, %b : i4
</code></pre><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>predicate</code></td><td align=center>::mlir::IntegerAttr</td><td>rtl.icmp comparison predicate</td></tr></tbody></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>an integer bitvector of one or more bits</td></tr><tr><td align=center><code>rhs</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=rtlinstance-circtrtlinstanceop><code>rtl.instance</code> (::circt::rtl::InstanceOp)&nbsp;<a class=headline-hash href=#rtlinstance-circtrtlinstanceop>¶</a></h3><p>Create an instance of a module</p><p>Syntax:</p><pre><code>operation ::= `rtl.instance` $instanceName $moduleName `(` $inputs `)` attr-dict
              `:` functional-type($inputs, results)
</code></pre><p>This represents an instance of a module. The inputs and results are
the referenced module&rsquo;s inputs and outputs. Any parameters are stored in
the &ldquo;parameters&rdquo; dictionary.</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>instanceName</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>moduleName</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td align=center><code>parameters</code></td><td align=center>::mlir::DictionaryAttr</td><td>dictionary of named attribute values</td></tr></tbody></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>any type</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=rtlmerge-circtrtlmergeop><code>rtl.merge</code> (::circt::rtl::MergeOp)&nbsp;<a class=headline-hash href=#rtlmerge-circtrtlmergeop>¶</a></h3><p>Electrically merge signals together as if connected by a wire.</p><p>Syntax:</p><pre><code>operation ::= `rtl.merge` $inputs attr-dict `:` type($result)
</code></pre><p>This operation merges multiple signals together as if they were connected to
a single wire. Presumably at most one of them should be a Z state at any
given time otherwise you&rsquo;d get a short circuit.</p><p>This operation allows modeling multiconnect semantics in SSA.</p><pre><code>  %result = rtl.merge %a, %b, %c : t1
</code></pre><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtlmods-circtrtlmodsop><code>rtl.mods</code> (::circt::rtl::ModSOp)&nbsp;<a class=headline-hash href=#rtlmods-circtrtlmodsop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `rtl.mods` $lhs `,` $rhs  attr-dict `:` type($result)
</code></pre><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>an integer bitvector of one or more bits</td></tr><tr><td align=center><code>rhs</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtlmodu-circtrtlmoduop><code>rtl.modu</code> (::circt::rtl::ModUOp)&nbsp;<a class=headline-hash href=#rtlmodu-circtrtlmoduop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `rtl.modu` $lhs `,` $rhs  attr-dict `:` type($result)
</code></pre><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>an integer bitvector of one or more bits</td></tr><tr><td align=center><code>rhs</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtlmul-circtrtlmulop><code>rtl.mul</code> (::circt::rtl::MulOp)&nbsp;<a class=headline-hash href=#rtlmul-circtrtlmulop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `rtl.mul` $inputs attr-dict `:` type($result)
</code></pre><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtlmux-circtrtlmuxop><code>rtl.mux</code> (::circt::rtl::MuxOp)&nbsp;<a class=headline-hash href=#rtlmux-circtrtlmuxop>¶</a></h3><p>Return one or the other operand depending on a selector bit</p><p>Syntax:</p><pre><code>operation ::= `rtl.mux` $cond `,` $trueValue `,` $falseValue attr-dict `:` type($result)
</code></pre><pre><code>  %0 = mux %pred, %tvalue, %fvalue : i4
</code></pre><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>cond</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>trueValue</code></td><td>a type without inout</td></tr><tr><td align=center><code>falseValue</code></td><td>a type without inout</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a type without inout</td></tr></tbody></table><h3 id=rtlor-circtrtlorop><code>rtl.or</code> (::circt::rtl::OrOp)&nbsp;<a class=headline-hash href=#rtlor-circtrtlorop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `rtl.or` $inputs attr-dict `:` type($result)
</code></pre><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtlorr-circtrtlorrop><code>rtl.orr</code> (::circt::rtl::OrROp)&nbsp;<a class=headline-hash href=#rtlorr-circtrtlorrop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `rtl.orr` $input attr-dict `:` type($input)
</code></pre><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=rtloutput-circtrtloutputop><code>rtl.output</code> (::circt::rtl::OutputOp)&nbsp;<a class=headline-hash href=#rtloutput-circtrtloutputop>¶</a></h3><p>RTL termination operation</p><p>Syntax:</p><pre><code>operation ::= `rtl.output` attr-dict ($operands^ `:` type($operands))?
</code></pre><p>&ldquo;rtl.output&rdquo; marks the end of a region in the RTL dialect and the values
to put on the output ports.</p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=rtlexternmodule-circtrtlrtlexternmoduleop><code>rtl.externmodule</code> (::circt::rtl::RTLExternModuleOp)&nbsp;<a class=headline-hash href=#rtlexternmodule-circtrtlrtlexternmoduleop>¶</a></h3><p>RTL external Module</p><p>The &ldquo;rtl.externmodule&rdquo; operation represents an external reference to a
Verilog module, including a given name and a list of ports.</p><p>The &lsquo;verilogName&rsquo; attribute (when present) specifies the spelling of the
module name in Verilog we can use. TODO: This is a hack because we don&rsquo;t
have proper parameterization in the rtl.dialect. We need a way to represent
parameterized types instead of just concrete types.</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>verilogName</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=rtlmodule-circtrtlrtlmoduleop><code>rtl.module</code> (::circt::rtl::RTLModuleOp)&nbsp;<a class=headline-hash href=#rtlmodule-circtrtlrtlmoduleop>¶</a></h3><p>RTL Module</p><p>The &ldquo;rtl.module&rdquo; operation represents a Verilog module, including a given
name, a list of ports, and a body that represents the connections within
the module.</p><h3 id=rtlsext-circtrtlsextop><code>rtl.sext</code> (::circt::rtl::SExtOp)&nbsp;<a class=headline-hash href=#rtlsext-circtrtlsextop>¶</a></h3><p>Sign extend an integer to a larger integer</p><p>Syntax:</p><pre><code>operation ::= `rtl.sext` $input attr-dict `:` functional-type($input, $result)
</code></pre><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtlshl-circtrtlshlop><code>rtl.shl</code> (::circt::rtl::ShlOp)&nbsp;<a class=headline-hash href=#rtlshl-circtrtlshlop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `rtl.shl` $lhs `,` $rhs  attr-dict `:` type($result)
</code></pre><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>an integer bitvector of one or more bits</td></tr><tr><td align=center><code>rhs</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtlshrs-circtrtlshrsop><code>rtl.shrs</code> (::circt::rtl::ShrSOp)&nbsp;<a class=headline-hash href=#rtlshrs-circtrtlshrsop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `rtl.shrs` $lhs `,` $rhs  attr-dict `:` type($result)
</code></pre><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>an integer bitvector of one or more bits</td></tr><tr><td align=center><code>rhs</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtlshru-circtrtlshruop><code>rtl.shru</code> (::circt::rtl::ShrUOp)&nbsp;<a class=headline-hash href=#rtlshru-circtrtlshruop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `rtl.shru` $lhs `,` $rhs  attr-dict `:` type($result)
</code></pre><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>an integer bitvector of one or more bits</td></tr><tr><td align=center><code>rhs</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtlstruct_create-circtrtlstructcreateop><code>rtl.struct_create</code> (::circt::rtl::StructCreateOp)&nbsp;<a class=headline-hash href=#rtlstruct_create-circtrtlstructcreateop>¶</a></h3><p>Create a struct from constituent parts.</p><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>a type without inout</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>RTL struct type</td></tr></tbody></table><h3 id=rtlstruct_explode-circtrtlstructexplodeop><code>rtl.struct_explode</code> (::circt::rtl::StructExplodeOp)&nbsp;<a class=headline-hash href=#rtlstruct_explode-circtrtlstructexplodeop>¶</a></h3><p>Expand a struct into its constituent parts.</p><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>RTL struct type</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a type without inout</td></tr></tbody></table><h3 id=rtlstruct_extract-circtrtlstructextractop><code>rtl.struct_extract</code> (::circt::rtl::StructExtractOp)&nbsp;<a class=headline-hash href=#rtlstruct_extract-circtrtlstructextractop>¶</a></h3><p>Extract a named field from a struct.</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>field</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>RTL struct type</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a type without inout</td></tr></tbody></table><h3 id=rtlstruct_inject-circtrtlstructinjectop><code>rtl.struct_inject</code> (::circt::rtl::StructInjectOp)&nbsp;<a class=headline-hash href=#rtlstruct_inject-circtrtlstructinjectop>¶</a></h3><p>Inject a value into a named field of a struct.</p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>field</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>RTL struct type</td></tr><tr><td align=center><code>newValue</code></td><td>a type without inout</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>RTL struct type</td></tr></tbody></table><h3 id=rtlsub-circtrtlsubop><code>rtl.sub</code> (::circt::rtl::SubOp)&nbsp;<a class=headline-hash href=#rtlsub-circtrtlsubop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `rtl.sub` $lhs `,` $rhs  attr-dict `:` type($result)
</code></pre><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>an integer bitvector of one or more bits</td></tr><tr><td align=center><code>rhs</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtlxor-circtrtlxorop><code>rtl.xor</code> (::circt::rtl::XorOp)&nbsp;<a class=headline-hash href=#rtlxor-circtrtlxorop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `rtl.xor` $inputs attr-dict `:` type($result)
</code></pre><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=rtlxorr-circtrtlxorrop><code>rtl.xorr</code> (::circt::rtl::XorROp)&nbsp;<a class=headline-hash href=#rtlxorr-circtrtlxorrop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `rtl.xorr` $input attr-dict `:` type($input)
</code></pre><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h2 id=type-definition>Type definition&nbsp;<a class=headline-hash href=#type-definition>¶</a></h2><h3 id=arraytype-arraytype><code>ArrayType</code> (ArrayType)&nbsp;<a class=headline-hash href=#arraytype-arraytype>¶</a></h3><p>fixed-sized array
Fixed sized RTL arrays are roughly similar to C arrays. On the wire (vs.
in a memory), arrays are always packed. Memory layout is not defined as
it does not need to be since in silicon there is not implicit memory
sharing.</p><h4 id=type-parameters>Type parameters:&nbsp;<a class=headline-hash href=#type-parameters>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>elementType</td><td align=center><code>ArrayType</code></td><td></td></tr><tr><td align=center>size</td><td align=center><code>ArrayType</code></td><td></td></tr></tbody></table><h3 id=inouttype-inouttype><code>InOutType</code> (InOutType)&nbsp;<a class=headline-hash href=#inouttype-inouttype>¶</a></h3><p>inout type
InOut type is used for model operations and values that have &ldquo;connection&rdquo;
semantics, instead of typical dataflow behavior. This is used for wires
and inout ports in Verilog.</p><h4 id=type-parameters-1>Type parameters:&nbsp;<a class=headline-hash href=#type-parameters-1>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>elementType</td><td align=center><code>InOutType</code></td><td></td></tr></tbody></table><h3 id=structtype-structtype><code>StructType</code> (StructType)&nbsp;<a class=headline-hash href=#structtype-structtype>¶</a></h3><p>RTL struct type
Represents a structure of name, value pairs.
!rtl.struct&lt;fieldName1: Type1, fieldName2: Type2></p><h4 id=type-parameters-2>Type parameters:&nbsp;<a class=headline-hash href=#type-parameters-2>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>elements</td><td align=center><code>StructType</code></td><td>struct fields</td></tr></tbody></table><h3 id=unpackedarraytype-unpackedarraytype><code>UnpackedArrayType</code> (UnpackedArrayType)&nbsp;<a class=headline-hash href=#unpackedarraytype-unpackedarraytype>¶</a></h3><p>SystemVerilog &lsquo;unpacked&rsquo; fixed-sized array
Unpacked arrays are a more flexible array representation than packed arrays,
and are typically used to model memories. See SystemVerilog Spec 7.4.2.</p><h4 id=type-parameters-3>Type parameters:&nbsp;<a class=headline-hash href=#type-parameters-3>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>elementType</td><td align=center><code>UnpackedArrayType</code></td><td></td></tr><tr><td align=center>size</td><td align=center><code>UnpackedArrayType</code></td><td></td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/LLHD/ title="'llhd' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'llhd' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/StaticLogic/ title="'staticlogic' Dialect">Next - 'staticlogic' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/ESI/>'esi' Dialect</a></li><li><a href=/docs/Dialects/FIRRTL/>'firrtl' Dialect</a></li><li><a href=/docs/Dialects/Handshake/>'handshake' Dialect</a></li><li><a href=/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=active><a href=/docs/Dialects/RTL/>'rtl' Dialect</a></li><li><a href=/docs/Dialects/StaticLogic/>'staticlogic' Dialect</a></li><li><a href=/docs/Dialects/SV/>'sv' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/ESI/>ESI<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/ESI/cosim/>ESI cosimulation model</a></li></ul></li><li><a href=/docs/SVPasses/></a></li><li><a href=/docs/Charter/>CIRCT Charter</a></li><li><a href=/docs/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/RationaleRTL-SV/>RTL and SV Dialect Rationale</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>