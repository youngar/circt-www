<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'firrtl' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.64.1"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/FIRRTL/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://circt.llvm.org/js/bundle.js></script><script type=text/javascript src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'firrtl' Dialect</h1><p>Types and operations for firrtl dialect
This dialect defines the <code>firrtl</code> dialect, which is used to lower from
Chisel code to Verilog. For more information, see the
<a href=https://github.com/freechipsproject/firrtl>FIRRTL GitHub page</a>
.</p><p><nav id=TableOfContents><ul><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#firrtladd-circtfirrtladdprimop>firrtl.add (::circt::firrtl::AddPrimOp)</a></li><li><a href=#firrtlanaloginoutcast-circtfirrtlanaloginoutcastop>firrtl.analogInOutCast (::circt::firrtl::AnalogInOutCastOp)</a></li><li><a href=#firrtland-circtfirrtlandprimop>firrtl.and (::circt::firrtl::AndPrimOp)</a></li><li><a href=#firrtlandr-circtfirrtlandrprimop>firrtl.andr (::circt::firrtl::AndRPrimOp)</a></li><li><a href=#firrtlasasyncreset-circtfirrtlasasyncresetprimop>firrtl.asAsyncReset (::circt::firrtl::AsAsyncResetPrimOp)</a></li><li><a href=#firrtlasclock-circtfirrtlasclockprimop>firrtl.asClock (::circt::firrtl::AsClockPrimOp)</a></li><li><a href=#firrtlasnonpassive-circtfirrtlasnonpassiveprimop>firrtl.asNonPassive (::circt::firrtl::AsNonPassivePrimOp)</a></li><li><a href=#firrtlaspassive-circtfirrtlaspassiveprimop>firrtl.asPassive (::circt::firrtl::AsPassivePrimOp)</a></li><li><a href=#firrtlassint-circtfirrtlassintprimop>firrtl.asSInt (::circt::firrtl::AsSIntPrimOp)</a></li><li><a href=#firrtlasuint-circtfirrtlasuintprimop>firrtl.asUInt (::circt::firrtl::AsUIntPrimOp)</a></li><li><a href=#firrtlassert-circtfirrtlassertop>firrtl.assert (::circt::firrtl::AssertOp)</a></li><li><a href=#firrtlassume-circtfirrtlassumeop>firrtl.assume (::circt::firrtl::AssumeOp)</a></li><li><a href=#firrtlattach-circtfirrtlattachop>firrtl.attach (::circt::firrtl::AttachOp)</a></li><li><a href=#firrtlbits-circtfirrtlbitsprimop>firrtl.bits (::circt::firrtl::BitsPrimOp)</a></li><li><a href=#firrtlcmem-circtfirrtlcmemop>firrtl.cmem (::circt::firrtl::CMemOp)</a></li><li><a href=#firrtlcat-circtfirrtlcatprimop>firrtl.cat (::circt::firrtl::CatPrimOp)</a></li><li><a href=#firrtlcircuit-circtfirrtlcircuitop>firrtl.circuit (::circt::firrtl::CircuitOp)</a></li><li><a href=#firrtlconnect-circtfirrtlconnectop>firrtl.connect (::circt::firrtl::ConnectOp)</a></li><li><a href=#firrtlconstant-circtfirrtlconstantop>firrtl.constant (::circt::firrtl::ConstantOp)</a></li><li><a href=#firrtlcover-circtfirrtlcoverop>firrtl.cover (::circt::firrtl::CoverOp)</a></li><li><a href=#firrtlcvt-circtfirrtlcvtprimop>firrtl.cvt (::circt::firrtl::CvtPrimOp)</a></li><li><a href=#firrtldshl-circtfirrtldshlprimop>firrtl.dshl (::circt::firrtl::DShlPrimOp)</a></li><li><a href=#firrtldshlw-circtfirrtldshlwprimop>firrtl.dshlw (::circt::firrtl::DShlwPrimOp)</a></li><li><a href=#firrtldshr-circtfirrtldshrprimop>firrtl.dshr (::circt::firrtl::DShrPrimOp)</a></li><li><a href=#firrtldiv-circtfirrtldivprimop>firrtl.div (::circt::firrtl::DivPrimOp)</a></li><li><a href=#firrtldone-circtfirrtldoneop>firrtl.done (::circt::firrtl::DoneOp)</a></li><li><a href=#firrtleq-circtfirrtleqprimop>firrtl.eq (::circt::firrtl::EQPrimOp)</a></li><li><a href=#firrtlextmodule-circtfirrtlfextmoduleop>firrtl.extmodule (::circt::firrtl::FExtModuleOp)</a></li><li><a href=#firrtlmodule-circtfirrtlfmoduleop>firrtl.module (::circt::firrtl::FModuleOp)</a></li><li><a href=#firrtlgeq-circtfirrtlgeqprimop>firrtl.geq (::circt::firrtl::GEQPrimOp)</a></li><li><a href=#firrtlgt-circtfirrtlgtprimop>firrtl.gt (::circt::firrtl::GTPrimOp)</a></li><li><a href=#firrtlhead-circtfirrtlheadprimop>firrtl.head (::circt::firrtl::HeadPrimOp)</a></li><li><a href=#firrtlinstance-circtfirrtlinstanceop>firrtl.instance (::circt::firrtl::InstanceOp)</a></li><li><a href=#firrtlinvalidvalue-circtfirrtlinvalidvalueprimop>firrtl.invalidvalue (::circt::firrtl::InvalidValuePrimOp)</a></li><li><a href=#firrtlleq-circtfirrtlleqprimop>firrtl.leq (::circt::firrtl::LEQPrimOp)</a></li><li><a href=#firrtllt-circtfirrtlltprimop>firrtl.lt (::circt::firrtl::LTPrimOp)</a></li><li><a href=#firrtlmem-circtfirrtlmemop>firrtl.mem (::circt::firrtl::MemOp)</a></li><li><a href=#firrtlmemoryport-circtfirrtlmemoryportop>firrtl.memoryport (::circt::firrtl::MemoryPortOp)</a></li><li><a href=#firrtlmul-circtfirrtlmulprimop>firrtl.mul (::circt::firrtl::MulPrimOp)</a></li><li><a href=#firrtlmux-circtfirrtlmuxprimop>firrtl.mux (::circt::firrtl::MuxPrimOp)</a></li><li><a href=#firrtlneq-circtfirrtlneqprimop>firrtl.neq (::circt::firrtl::NEQPrimOp)</a></li><li><a href=#firrtlneg-circtfirrtlnegprimop>firrtl.neg (::circt::firrtl::NegPrimOp)</a></li><li><a href=#firrtlnode-circtfirrtlnodeop>firrtl.node (::circt::firrtl::NodeOp)</a></li><li><a href=#firrtlnot-circtfirrtlnotprimop>firrtl.not (::circt::firrtl::NotPrimOp)</a></li><li><a href=#firrtlor-circtfirrtlorprimop>firrtl.or (::circt::firrtl::OrPrimOp)</a></li><li><a href=#firrtlorr-circtfirrtlorrprimop>firrtl.orr (::circt::firrtl::OrRPrimOp)</a></li><li><a href=#firrtlpad-circtfirrtlpadprimop>firrtl.pad (::circt::firrtl::PadPrimOp)</a></li><li><a href=#firrtlpartialconnect-circtfirrtlpartialconnectop>firrtl.partialconnect (::circt::firrtl::PartialConnectOp)</a></li><li><a href=#firrtlprintf-circtfirrtlprintfop>firrtl.printf (::circt::firrtl::PrintFOp)</a></li><li><a href=#firrtlrtlstructcast-circtfirrtlrtlstructcastop>firrtl.rtlStructCast (::circt::firrtl::RTLStructCastOp)</a></li><li><a href=#firrtlreg-circtfirrtlregop>firrtl.reg (::circt::firrtl::RegOp)</a></li><li><a href=#firrtlregreset-circtfirrtlregresetop>firrtl.regreset (::circt::firrtl::RegResetOp)</a></li><li><a href=#firrtlrem-circtfirrtlremprimop>firrtl.rem (::circt::firrtl::RemPrimOp)</a></li><li><a href=#firrtlsmem-circtfirrtlsmemop>firrtl.smem (::circt::firrtl::SMemOp)</a></li><li><a href=#firrtlshl-circtfirrtlshlprimop>firrtl.shl (::circt::firrtl::ShlPrimOp)</a></li><li><a href=#firrtlshr-circtfirrtlshrprimop>firrtl.shr (::circt::firrtl::ShrPrimOp)</a></li><li><a href=#firrtlskip-circtfirrtlskipop>firrtl.skip (::circt::firrtl::SkipOp)</a></li><li><a href=#firrtlstdintcast-circtfirrtlstdintcastop>firrtl.stdIntCast (::circt::firrtl::StdIntCastOp)</a></li><li><a href=#firrtlstop-circtfirrtlstopop>firrtl.stop (::circt::firrtl::StopOp)</a></li><li><a href=#firrtlsub-circtfirrtlsubprimop>firrtl.sub (::circt::firrtl::SubPrimOp)</a></li><li><a href=#firrtlsubaccess-circtfirrtlsubaccessop>firrtl.subaccess (::circt::firrtl::SubaccessOp)</a></li><li><a href=#firrtlsubfield-circtfirrtlsubfieldop>firrtl.subfield (::circt::firrtl::SubfieldOp)</a></li><li><a href=#firrtlsubindex-circtfirrtlsubindexop>firrtl.subindex (::circt::firrtl::SubindexOp)</a></li><li><a href=#firrtltail-circtfirrtltailprimop>firrtl.tail (::circt::firrtl::TailPrimOp)</a></li><li><a href=#firrtlvalidif-circtfirrtlvalidifprimop>firrtl.validif (::circt::firrtl::ValidIfPrimOp)</a></li><li><a href=#firrtlwhen-circtfirrtlwhenop>firrtl.when (::circt::firrtl::WhenOp)</a></li><li><a href=#firrtlwire-circtfirrtlwireop>firrtl.wire (::circt::firrtl::WireOp)</a></li><li><a href=#firrtlxor-circtfirrtlxorprimop>firrtl.xor (::circt::firrtl::XorPrimOp)</a></li><li><a href=#firrtlxorr-circtfirrtlxorrprimop>firrtl.xorr (::circt::firrtl::XorRPrimOp)</a></li></ul></li></ul></nav><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=firrtladd-circtfirrtladdprimop><code>firrtl.add</code> (::circt::firrtl::AddPrimOp)&nbsp;<a class=headline-hash href=#firrtladd-circtfirrtladdprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.add` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlanaloginoutcast-circtfirrtlanaloginoutcastop><code>firrtl.analogInOutCast</code> (::circt::firrtl::AnalogInOutCastOp)&nbsp;<a class=headline-hash href=#firrtlanaloginoutcast-circtfirrtlanaloginoutcastop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.analogInOutCast` $input attr-dict `:` functional-type($input, $result)
</code></pre><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>any type</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=firrtland-circtfirrtlandprimop><code>firrtl.and</code> (::circt::firrtl::AndPrimOp)&nbsp;<a class=headline-hash href=#firrtland-circtfirrtlandprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.and` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlandr-circtfirrtlandrprimop><code>firrtl.andr</code> (::circt::firrtl::AndRPrimOp)&nbsp;<a class=headline-hash href=#firrtlandr-circtfirrtlandrprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.andr` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Horizontally reduce a value to one bit, using the &lsquo;and&rsquo; operation to merge
bits. <code>andr(x)</code> is equivalent to <code>concat(x, 1b1) == ~0</code>. As such, it
returns 1 for zero-bit-wide operands.</p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlasasyncreset-circtfirrtlasasyncresetprimop><code>firrtl.asAsyncReset</code> (::circt::firrtl::AsAsyncResetPrimOp)&nbsp;<a class=headline-hash href=#firrtlasasyncreset-circtfirrtlasasyncresetprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.asAsyncReset` $input attr-dict `:` functional-type($input, $result)
</code></pre><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>1-bit uint/sint/analog, reset, asyncreset, or clock</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>AsyncReset</td></tr></tbody></table><h3 id=firrtlasclock-circtfirrtlasclockprimop><code>firrtl.asClock</code> (::circt::firrtl::AsClockPrimOp)&nbsp;<a class=headline-hash href=#firrtlasclock-circtfirrtlasclockprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.asClock` $input attr-dict `:` functional-type($input, $result)
</code></pre><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>1-bit uint/sint/analog, reset, asyncreset, or clock</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>clock</td></tr></tbody></table><h3 id=firrtlasnonpassive-circtfirrtlasnonpassiveprimop><code>firrtl.asNonPassive</code> (::circt::firrtl::AsNonPassivePrimOp)&nbsp;<a class=headline-hash href=#firrtlasnonpassive-circtfirrtlasnonpassiveprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.asNonPassive` $input attr-dict `:` type($result)
</code></pre><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlaspassive-circtfirrtlaspassiveprimop><code>firrtl.asPassive</code> (::circt::firrtl::AsPassivePrimOp)&nbsp;<a class=headline-hash href=#firrtlaspassive-circtfirrtlaspassiveprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.asPassive` $input attr-dict `:` type($input)
</code></pre><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>FIRRTLType</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h3 id=firrtlassint-circtfirrtlassintprimop><code>firrtl.asSInt</code> (::circt::firrtl::AsSIntPrimOp)&nbsp;<a class=headline-hash href=#firrtlassint-circtfirrtlassintprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.asSInt` $input attr-dict `:` functional-type($input, $result)
</code></pre><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>FIRRTLType</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint type</td></tr></tbody></table><h3 id=firrtlasuint-circtfirrtlasuintprimop><code>firrtl.asUInt</code> (::circt::firrtl::AsUIntPrimOp)&nbsp;<a class=headline-hash href=#firrtlasuint-circtfirrtlasuintprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.asUInt` $input attr-dict `:` functional-type($input, $result)
</code></pre><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>FIRRTLType</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlassert-circtfirrtlassertop><code>firrtl.assert</code> (::circt::firrtl::AssertOp)&nbsp;<a class=headline-hash href=#firrtlassert-circtfirrtlassertop>¶</a></h3><p>Assert Verification Statement</p><p>Syntax:</p><pre><code>operation ::= `firrtl.assert` $clock `,` $predicate `,` $enable `,` $message attr-dict
</code></pre><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>message</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clock</code></td><td>clock</td></tr><tr><td align=center><code>predicate</code></td><td>UInt&lt;1></td></tr><tr><td align=center><code>enable</code></td><td>UInt&lt;1></td></tr></tbody></table><h3 id=firrtlassume-circtfirrtlassumeop><code>firrtl.assume</code> (::circt::firrtl::AssumeOp)&nbsp;<a class=headline-hash href=#firrtlassume-circtfirrtlassumeop>¶</a></h3><p>Assume Verification Statement</p><p>Syntax:</p><pre><code>operation ::= `firrtl.assume` $clock `,` $predicate `,` $enable `,` $message attr-dict
</code></pre><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>message</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clock</code></td><td>clock</td></tr><tr><td align=center><code>predicate</code></td><td>UInt&lt;1></td></tr><tr><td align=center><code>enable</code></td><td>UInt&lt;1></td></tr></tbody></table><h3 id=firrtlattach-circtfirrtlattachop><code>firrtl.attach</code> (::circt::firrtl::AttachOp)&nbsp;<a class=headline-hash href=#firrtlattach-circtfirrtlattachop>¶</a></h3><p>Analog Attach Statement</p><p>Syntax:</p><pre><code>operation ::= `firrtl.attach` $operands attr-dict `:` type($operands)
</code></pre><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>analog type</td></tr></tbody></table><h3 id=firrtlbits-circtfirrtlbitsprimop><code>firrtl.bits</code> (::circt::firrtl::BitsPrimOp)&nbsp;<a class=headline-hash href=#firrtlbits-circtfirrtlbitsprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.bits` $input $hi `to` $lo attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>bits</code> operation extracts the bits between <code>hi</code> (inclusive) and <code>lo</code>
(inclusive) from <code>input</code>. <code>hi</code> must be greater than or equal to <code>lo</code>. Both
<code>hi</code> and <code>lo</code> must be non-negative and less than the bit width of <code>input</code>.
The result is <code>hi - lo + 1</code> bits wide.</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>hi</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>lo</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlcmem-circtfirrtlcmemop><code>firrtl.cmem</code> (::circt::firrtl::CMemOp)&nbsp;<a class=headline-hash href=#firrtlcmem-circtfirrtlcmemop>¶</a></h3><p>Define a new cmem</p><p>Syntax:</p><pre><code>operation ::= `firrtl.cmem` attr-dict `:` type($result)
</code></pre><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlcat-circtfirrtlcatprimop><code>firrtl.cat</code> (::circt::firrtl::CatPrimOp)&nbsp;<a class=headline-hash href=#firrtlcat-circtfirrtlcatprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.cat` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlcircuit-circtfirrtlcircuitop><code>firrtl.circuit</code> (::circt::firrtl::CircuitOp)&nbsp;<a class=headline-hash href=#firrtlcircuit-circtfirrtlcircuitop>¶</a></h3><p>FIRRTL Circuit</p><p>The &ldquo;firrtl.circuit&rdquo; operation represents an overall Verilog circuit,
containing a list of modules.</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=firrtlconnect-circtfirrtlconnectop><code>firrtl.connect</code> (::circt::firrtl::ConnectOp)&nbsp;<a class=headline-hash href=#firrtlconnect-circtfirrtlconnectop>¶</a></h3><p>Connect two signals</p><p>Syntax:</p><pre><code>operation ::= `firrtl.connect` $dest `,` $src  attr-dict `:` type($dest) `,` type($src)
</code></pre><p>Connect Operation:</p><pre><code>  firrtl.connect %dest, %src : t1, t2
</code></pre><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>FIRRTLType</td></tr><tr><td align=center><code>src</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlconstant-circtfirrtlconstantop><code>firrtl.constant</code> (::circt::firrtl::ConstantOp)&nbsp;<a class=headline-hash href=#firrtlconstant-circtfirrtlconstantop>¶</a></h3><p>Produce a constant value</p><p>Syntax:</p><pre><code>operation ::= `firrtl.constant` `(` $value `)` attr-dict `:` type($result)
</code></pre><p>The constant operation produces a constant value of SInt or UInt type, it
never produces a zero bit wide result.</p><pre><code>  %result = firrtl.constant 42 : t1
</code></pre><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td align=center>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>Int</td></tr></tbody></table><h3 id=firrtlcover-circtfirrtlcoverop><code>firrtl.cover</code> (::circt::firrtl::CoverOp)&nbsp;<a class=headline-hash href=#firrtlcover-circtfirrtlcoverop>¶</a></h3><p>Cover Verification Statement</p><p>Syntax:</p><pre><code>operation ::= `firrtl.cover` $clock `,` $predicate `,` $enable `,` $message attr-dict
</code></pre><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>message</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clock</code></td><td>clock</td></tr><tr><td align=center><code>predicate</code></td><td>UInt&lt;1></td></tr><tr><td align=center><code>enable</code></td><td>UInt&lt;1></td></tr></tbody></table><h3 id=firrtlcvt-circtfirrtlcvtprimop><code>firrtl.cvt</code> (::circt::firrtl::CvtPrimOp)&nbsp;<a class=headline-hash href=#firrtlcvt-circtfirrtlcvtprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.cvt` $input attr-dict `:` functional-type($input, $result)
</code></pre><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint type</td></tr></tbody></table><h3 id=firrtldshl-circtfirrtldshlprimop><code>firrtl.dshl</code> (::circt::firrtl::DShlPrimOp)&nbsp;<a class=headline-hash href=#firrtldshl-circtfirrtldshlprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.dshl` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>uint type</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtldshlw-circtfirrtldshlwprimop><code>firrtl.dshlw</code> (::circt::firrtl::DShlwPrimOp)&nbsp;<a class=headline-hash href=#firrtldshlw-circtfirrtldshlwprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.dshlw` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>uint type</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtldshr-circtfirrtldshrprimop><code>firrtl.dshr</code> (::circt::firrtl::DShrPrimOp)&nbsp;<a class=headline-hash href=#firrtldshr-circtfirrtldshrprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.dshr` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>uint type</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtldiv-circtfirrtldivprimop><code>firrtl.div</code> (::circt::firrtl::DivPrimOp)&nbsp;<a class=headline-hash href=#firrtldiv-circtfirrtldivprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.div` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><p>Divides the first argument (the numerator) by the second argument
(the denominator) truncating the result (rounding towards zero).</p><p><strong>If the denominator is zero, the result is undefined.</strong></p><p>The compiler may optimize this undefined behavior in any way it
wants. Notably <code>div(a, a)</code> will be optimized to <code>1</code>. This may cause
erroneous formal equivalence mismatches between unoptimized and
optimized FIRRTL dialects that are separately converted to Verilog.</p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtldone-circtfirrtldoneop><code>firrtl.done</code> (::circt::firrtl::DoneOp)&nbsp;<a class=headline-hash href=#firrtldone-circtfirrtldoneop>¶</a></h3><p>FIRRTL termination operation</p><p>&ldquo;firrtl.done&rdquo; marks the end of a region in the FIRRTL dialect.</p><h3 id=firrtleq-circtfirrtleqprimop><code>firrtl.eq</code> (::circt::firrtl::EQPrimOp)&nbsp;<a class=headline-hash href=#firrtleq-circtfirrtleqprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.eq` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>UInt&lt;1></td></tr></tbody></table><h3 id=firrtlextmodule-circtfirrtlfextmoduleop><code>firrtl.extmodule</code> (::circt::firrtl::FExtModuleOp)&nbsp;<a class=headline-hash href=#firrtlextmodule-circtfirrtlfextmoduleop>¶</a></h3><p>FIRRTL extmodule</p><p>The &ldquo;firrtl.extmodule&rdquo; operation represents an external reference to a
Verilog module, including a given name and a list of ports.</p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>defname</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>parameters</code></td><td align=center>::mlir::DictionaryAttr</td><td>dictionary of named attribute values</td></tr></tbody></table><h3 id=firrtlmodule-circtfirrtlfmoduleop><code>firrtl.module</code> (::circt::firrtl::FModuleOp)&nbsp;<a class=headline-hash href=#firrtlmodule-circtfirrtlfmoduleop>¶</a></h3><p>FIRRTL Module</p><p>The &ldquo;firrtl.module&rdquo; operation represents a Verilog module, including a given
name, a list of ports, and a body that represents the connections within
the module.</p><h3 id=firrtlgeq-circtfirrtlgeqprimop><code>firrtl.geq</code> (::circt::firrtl::GEQPrimOp)&nbsp;<a class=headline-hash href=#firrtlgeq-circtfirrtlgeqprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.geq` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>UInt&lt;1></td></tr></tbody></table><h3 id=firrtlgt-circtfirrtlgtprimop><code>firrtl.gt</code> (::circt::firrtl::GTPrimOp)&nbsp;<a class=headline-hash href=#firrtlgt-circtfirrtlgtprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.gt` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>UInt&lt;1></td></tr></tbody></table><h3 id=firrtlhead-circtfirrtlheadprimop><code>firrtl.head</code> (::circt::firrtl::HeadPrimOp)&nbsp;<a class=headline-hash href=#firrtlhead-circtfirrtlheadprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.head` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>amount</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlinstance-circtfirrtlinstanceop><code>firrtl.instance</code> (::circt::firrtl::InstanceOp)&nbsp;<a class=headline-hash href=#firrtlinstance-circtfirrtlinstanceop>¶</a></h3><p>Instantiate an instance of a module</p><p>Syntax:</p><pre><code>operation ::= `firrtl.instance` $moduleName attr-dict (`:` type($results)^ )?
</code></pre><p>This represents an instance of a module. The results are the modules inputs
and outputs. The inputs have flip type, the outputs do not.</p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>moduleName</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td align=center><code>portNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>results</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlinvalidvalue-circtfirrtlinvalidvalueprimop><code>firrtl.invalidvalue</code> (::circt::firrtl::InvalidValuePrimOp)&nbsp;<a class=headline-hash href=#firrtlinvalidvalue-circtfirrtlinvalidvalueprimop>¶</a></h3><p>InvalidValue primitive</p><p>Syntax:</p><pre><code>operation ::= `firrtl.invalidvalue` attr-dict `:` type($result)
</code></pre><p>The InvalidValue operation returns an invalid value of a specified type:</p><pre><code>  %result = firrtl.invalid : !firrtl.uint&lt;1&gt;
</code></pre><p>This corresponds to the FIRRTL invalidate operation without the implicit
connect semantics.</p><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlleq-circtfirrtlleqprimop><code>firrtl.leq</code> (::circt::firrtl::LEQPrimOp)&nbsp;<a class=headline-hash href=#firrtlleq-circtfirrtlleqprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.leq` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>UInt&lt;1></td></tr></tbody></table><h3 id=firrtllt-circtfirrtlltprimop><code>firrtl.lt</code> (::circt::firrtl::LTPrimOp)&nbsp;<a class=headline-hash href=#firrtllt-circtfirrtlltprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.lt` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>UInt&lt;1></td></tr></tbody></table><h3 id=firrtlmem-circtfirrtlmemop><code>firrtl.mem</code> (::circt::firrtl::MemOp)&nbsp;<a class=headline-hash href=#firrtlmem-circtfirrtlmemop>¶</a></h3><p>Define a new mem</p><p>Syntax:</p><pre><code>operation ::= `firrtl.mem` $ruw attr-dict `:` type($results)
</code></pre><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>readLatency</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td align=center><code>writeLatency</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 1</td></tr><tr><td align=center><code>depth</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 1</td></tr><tr><td align=center><code>ruw</code></td><td align=center>::mlir::IntegerAttr</td><td>Read Under Write Enum</td></tr><tr><td align=center><code>portNames</code></td><td align=center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>results</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlmemoryport-circtfirrtlmemoryportop><code>firrtl.memoryport</code> (::circt::firrtl::MemoryPortOp)&nbsp;<a class=headline-hash href=#firrtlmemoryport-circtfirrtlmemoryportop>¶</a></h3><p>Access a memory</p><p>Syntax:</p><pre><code>operation ::= `firrtl.memoryport` $direction $memory `,` $index `,` $clock attr-dict `:`
              functional-type(operands, $result)
</code></pre><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>direction</code></td><td align=center>::mlir::IntegerAttr</td><td>Memory Direction Enum</td></tr><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>memory</code></td><td>FIRRTLType</td></tr><tr><td align=center><code>index</code></td><td>sint or uint type</td></tr><tr><td align=center><code>clock</code></td><td>clock</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlmul-circtfirrtlmulprimop><code>firrtl.mul</code> (::circt::firrtl::MulPrimOp)&nbsp;<a class=headline-hash href=#firrtlmul-circtfirrtlmulprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.mul` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlmux-circtfirrtlmuxprimop><code>firrtl.mux</code> (::circt::firrtl::MuxPrimOp)&nbsp;<a class=headline-hash href=#firrtlmux-circtfirrtlmuxprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.mux` `(` operands `)` attr-dict `:` functional-type(operands, $result)
</code></pre><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sel</code></td><td>UInt&lt;1></td></tr><tr><td align=center><code>high</code></td><td>a passive type (contain no flips)</td></tr><tr><td align=center><code>low</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h3 id=firrtlneq-circtfirrtlneqprimop><code>firrtl.neq</code> (::circt::firrtl::NEQPrimOp)&nbsp;<a class=headline-hash href=#firrtlneq-circtfirrtlneqprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.neq` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>UInt&lt;1></td></tr></tbody></table><h3 id=firrtlneg-circtfirrtlnegprimop><code>firrtl.neg</code> (::circt::firrtl::NegPrimOp)&nbsp;<a class=headline-hash href=#firrtlneg-circtfirrtlnegprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.neg` $input attr-dict `:` functional-type($input, $result)
</code></pre><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint type</td></tr></tbody></table><h3 id=firrtlnode-circtfirrtlnodeop><code>firrtl.node</code> (::circt::firrtl::NodeOp)&nbsp;<a class=headline-hash href=#firrtlnode-circtfirrtlnodeop>¶</a></h3><p>No-op to name a value</p><p>Syntax:</p><pre><code>operation ::= `firrtl.node` $input custom&lt;ImplicitSSAName&gt;(attr-dict) `:` type($input)
</code></pre><p>A node is simply a named intermediate value in a circuit. The node must
be initialized to a value with a passive type and cannot be connected to.
Nodes are often used to split a complicated compound expression into named
subexpressions.</p><pre><code>  %result = firrtl.node %input : t1
</code></pre><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlnot-circtfirrtlnotprimop><code>firrtl.not</code> (::circt::firrtl::NotPrimOp)&nbsp;<a class=headline-hash href=#firrtlnot-circtfirrtlnotprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.not` $input attr-dict `:` functional-type($input, $result)
</code></pre><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlor-circtfirrtlorprimop><code>firrtl.or</code> (::circt::firrtl::OrPrimOp)&nbsp;<a class=headline-hash href=#firrtlor-circtfirrtlorprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.or` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlorr-circtfirrtlorrprimop><code>firrtl.orr</code> (::circt::firrtl::OrRPrimOp)&nbsp;<a class=headline-hash href=#firrtlorr-circtfirrtlorrprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.orr` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Horizontally reduce a value to one bit, using the &lsquo;or&rsquo; operation to merge
bits. <code>orr(x)</code> is equivalent to <code>concat(x, 1b0) != 0</code>. As such, it returns
0 for zero-bit-wide operands.</p><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlpad-circtfirrtlpadprimop><code>firrtl.pad</code> (::circt::firrtl::PadPrimOp)&nbsp;<a class=headline-hash href=#firrtlpad-circtfirrtlpadprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.pad` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>Pad the input out to an <code>amount</code> wide integer, sign extending or zero
extending according to <code>input</code>s type. If <code>amount</code> is less than the existing
width of <code>input</code>, then input is unmodified.</p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>amount</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlpartialconnect-circtfirrtlpartialconnectop><code>firrtl.partialconnect</code> (::circt::firrtl::PartialConnectOp)&nbsp;<a class=headline-hash href=#firrtlpartialconnect-circtfirrtlpartialconnectop>¶</a></h3><p>Connect two signals</p><p>Syntax:</p><pre><code>operation ::= `firrtl.partialconnect` $dest `,` $src  attr-dict `:` type($dest) `,` type($src)
</code></pre><p>Connect two values with fewer constraints:</p><pre><code>  firrtl.partialconnect %dest, %src : t1, t2
</code></pre><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>FIRRTLType</td></tr><tr><td align=center><code>src</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlprintf-circtfirrtlprintfop><code>firrtl.printf</code> (::circt::firrtl::PrintFOp)&nbsp;<a class=headline-hash href=#firrtlprintf-circtfirrtlprintfop>¶</a></h3><p>Formatted Print Statement</p><p>Syntax:</p><pre><code>operation ::= `firrtl.printf` $clock `,` $cond `,` $formatString attr-dict (`(` $operands^ `)`
              `:` type($operands))?
</code></pre><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>formatString</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clock</code></td><td>clock</td></tr><tr><td align=center><code>cond</code></td><td>UInt&lt;1></td></tr><tr><td align=center><code>operands</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlrtlstructcast-circtfirrtlrtlstructcastop><code>firrtl.rtlStructCast</code> (::circt::firrtl::RTLStructCastOp)&nbsp;<a class=headline-hash href=#firrtlrtlstructcast-circtfirrtlrtlstructcastop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.rtlStructCast` $input attr-dict `:` functional-type($input, $result)
</code></pre><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>any type</td></tr></tbody></table><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=firrtlreg-circtfirrtlregop><code>firrtl.reg</code> (::circt::firrtl::RegOp)&nbsp;<a class=headline-hash href=#firrtlreg-circtfirrtlregop>¶</a></h3><p>Define a new register</p><p>Syntax:</p><pre><code>operation ::= `firrtl.reg` operands attr-dict `:` functional-type(operands, $result)
</code></pre><p>Declare a new register:</p><pre><code>  %name = firrtl.reg %clockVal : t1
</code></pre><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clockVal</code></td><td>clock</td></tr></tbody></table><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h3 id=firrtlregreset-circtfirrtlregresetop><code>firrtl.regreset</code> (::circt::firrtl::RegResetOp)&nbsp;<a class=headline-hash href=#firrtlregreset-circtfirrtlregresetop>¶</a></h3><p>Define a new register with a reset</p><p>Syntax:</p><pre><code>operation ::= `firrtl.regreset` operands attr-dict `:` functional-type(operands, $result)
</code></pre><p>Declare a new register:</p><pre><code>  %name = firrtl.regreset %clockVal, %resetSignal, %resetValue : t1
</code></pre><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-42>Operands:&nbsp;<a class=headline-hash href=#operands-42>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clockVal</code></td><td>clock</td></tr><tr><td align=center><code>resetSignal</code></td><td>Reset</td></tr><tr><td align=center><code>resetValue</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h3 id=firrtlrem-circtfirrtlremprimop><code>firrtl.rem</code> (::circt::firrtl::RemPrimOp)&nbsp;<a class=headline-hash href=#firrtlrem-circtfirrtlremprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.rem` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands-43>Operands:&nbsp;<a class=headline-hash href=#operands-43>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlsmem-circtfirrtlsmemop><code>firrtl.smem</code> (::circt::firrtl::SMemOp)&nbsp;<a class=headline-hash href=#firrtlsmem-circtfirrtlsmemop>¶</a></h3><p>Define a new smem</p><p>Syntax:</p><pre><code>operation ::= `firrtl.smem` $ruw attr-dict `:` type($result)
</code></pre><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>ruw</code></td><td align=center>::mlir::IntegerAttr</td><td>Read Under Write Enum</td></tr><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-42>Results:&nbsp;<a class=headline-hash href=#results-42>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlshl-circtfirrtlshlprimop><code>firrtl.shl</code> (::circt::firrtl::ShlPrimOp)&nbsp;<a class=headline-hash href=#firrtlshl-circtfirrtlshlprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.shl` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>shl</code> operation concatenates <code>amount</code> zero bits to the least significant
end of <code>input</code>. <code>amount</code> must be non-negative.</p><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>amount</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-44>Operands:&nbsp;<a class=headline-hash href=#operands-44>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-43>Results:&nbsp;<a class=headline-hash href=#results-43>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlshr-circtfirrtlshrprimop><code>firrtl.shr</code> (::circt::firrtl::ShrPrimOp)&nbsp;<a class=headline-hash href=#firrtlshr-circtfirrtlshrprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.shr` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>shr</code> operation truncates least significant <code>amount</code> bits from <code>input</code>.
If <code>amount</code> is greater than of equal to <code>width(input)</code>, the value will be
zero for unsigned types and the sign bit for signed types. <code>amount</code> must be
non-negative.</p><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>amount</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-45>Operands:&nbsp;<a class=headline-hash href=#operands-45>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-44>Results:&nbsp;<a class=headline-hash href=#results-44>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlskip-circtfirrtlskipop><code>firrtl.skip</code> (::circt::firrtl::SkipOp)&nbsp;<a class=headline-hash href=#firrtlskip-circtfirrtlskipop>¶</a></h3><p>Skip statement</p><p>Syntax:</p><pre><code>operation ::= `firrtl.skip` attr-dict
</code></pre><p>Skip Statement:</p><pre><code>   %firrtl.skip
</code></pre><p>This is a no-op statement.</p><h3 id=firrtlstdintcast-circtfirrtlstdintcastop><code>firrtl.stdIntCast</code> (::circt::firrtl::StdIntCastOp)&nbsp;<a class=headline-hash href=#firrtlstdintcast-circtfirrtlstdintcastop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.stdIntCast` $input attr-dict `:` functional-type($input, $result)
</code></pre><h4 id=operands-46>Operands:&nbsp;<a class=headline-hash href=#operands-46>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>passive FIRRTL type or signless builtin integer</td></tr></tbody></table><h4 id=results-45>Results:&nbsp;<a class=headline-hash href=#results-45>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>passive FIRRTL type or signless builtin integer</td></tr></tbody></table><h3 id=firrtlstop-circtfirrtlstopop><code>firrtl.stop</code> (::circt::firrtl::StopOp)&nbsp;<a class=headline-hash href=#firrtlstop-circtfirrtlstopop>¶</a></h3><p>Stop Statement</p><p>Syntax:</p><pre><code>operation ::= `firrtl.stop` $clock `,` $cond `,` $exitCode attr-dict
</code></pre><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>exitCode</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-47>Operands:&nbsp;<a class=headline-hash href=#operands-47>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clock</code></td><td>clock</td></tr><tr><td align=center><code>cond</code></td><td>UInt&lt;1></td></tr></tbody></table><h3 id=firrtlsub-circtfirrtlsubprimop><code>firrtl.sub</code> (::circt::firrtl::SubPrimOp)&nbsp;<a class=headline-hash href=#firrtlsub-circtfirrtlsubprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.sub` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands-48>Operands:&nbsp;<a class=headline-hash href=#operands-48>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-46>Results:&nbsp;<a class=headline-hash href=#results-46>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlsubaccess-circtfirrtlsubaccessop><code>firrtl.subaccess</code> (::circt::firrtl::SubaccessOp)&nbsp;<a class=headline-hash href=#firrtlsubaccess-circtfirrtlsubaccessop>¶</a></h3><p>Extract a dynamic element of a vector value</p><p>Syntax:</p><pre><code>operation ::= `firrtl.subaccess` $input `[` $index `]` attr-dict `:` type($input) `,` type($index)
</code></pre><p>The subaccess expression dynamically refers to a subelement of a
vector-typed expression using a calculated index. The index must be an
expression with an unsigned integer type.</p><pre><code>  %result = firrtl.subaccess %input[%idx] : t1, t2
</code></pre><h4 id=operands-49>Operands:&nbsp;<a class=headline-hash href=#operands-49>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>FIRRTLType</td></tr><tr><td align=center><code>index</code></td><td>uint type</td></tr></tbody></table><h4 id=results-47>Results:&nbsp;<a class=headline-hash href=#results-47>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlsubfield-circtfirrtlsubfieldop><code>firrtl.subfield</code> (::circt::firrtl::SubfieldOp)&nbsp;<a class=headline-hash href=#firrtlsubfield-circtfirrtlsubfieldop>¶</a></h3><p>Extract a subfield of another value</p><p>Syntax:</p><pre><code>operation ::= `firrtl.subfield` $input `(` $fieldname `)` attr-dict `:` functional-type($input, $result)
</code></pre><p>The subfield expression refers to a subelement of an expression with a
bundle type.</p><pre><code>  %result = firrtl.subfield %input &quot;fieldname&quot; : t1, t2
</code></pre><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>fieldname</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-50>Operands:&nbsp;<a class=headline-hash href=#operands-50>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>FIRRTLType</td></tr></tbody></table><h4 id=results-48>Results:&nbsp;<a class=headline-hash href=#results-48>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlsubindex-circtfirrtlsubindexop><code>firrtl.subindex</code> (::circt::firrtl::SubindexOp)&nbsp;<a class=headline-hash href=#firrtlsubindex-circtfirrtlsubindexop>¶</a></h3><p>Extract an element of a vector value</p><p>Syntax:</p><pre><code>operation ::= `firrtl.subindex` $input `[` $index `]` attr-dict `:` type($input)
</code></pre><p>The subindex expression statically refers, by index, to a subelement
of an expression with a vector type. The index must be a non-negative
integer and cannot be equal to or exceed the length of the vector it
indexes.</p><pre><code>  %result = firrtl.subindex %input[index] : t1
</code></pre><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>index</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-51>Operands:&nbsp;<a class=headline-hash href=#operands-51>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>FVectorType</td></tr></tbody></table><h4 id=results-49>Results:&nbsp;<a class=headline-hash href=#results-49>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtltail-circtfirrtltailprimop><code>firrtl.tail</code> (::circt::firrtl::TailPrimOp)&nbsp;<a class=headline-hash href=#firrtltail-circtfirrtltailprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.tail` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>tail</code> operation truncates the <code>amount</code> most significant bits from
<code>input</code>. <code>amount</code> must be non-negative and less than or equal to the bit
width of e. The result is <code>width(input)-amount</code> bits wide.</p><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>amount</code></td><td align=center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-52>Operands:&nbsp;<a class=headline-hash href=#operands-52>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-50>Results:&nbsp;<a class=headline-hash href=#results-50>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlvalidif-circtfirrtlvalidifprimop><code>firrtl.validif</code> (::circt::firrtl::ValidIfPrimOp)&nbsp;<a class=headline-hash href=#firrtlvalidif-circtfirrtlvalidifprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.validif` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands-53>Operands:&nbsp;<a class=headline-hash href=#operands-53>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>UInt&lt;1></td></tr><tr><td align=center><code>rhs</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h4 id=results-51>Results:&nbsp;<a class=headline-hash href=#results-51>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h3 id=firrtlwhen-circtfirrtlwhenop><code>firrtl.when</code> (::circt::firrtl::WhenOp)&nbsp;<a class=headline-hash href=#firrtlwhen-circtfirrtlwhenop>¶</a></h3><p>When Statement</p><p>Syntax:</p><pre><code>operation ::= `firrtl.when` $condition $thenRegion (`else` $elseRegion^)? attr-dict-with-keyword
</code></pre><p>The &ldquo;firrtl.when&rdquo; operation represents a conditional. Connections within
a conditional statement that connect to previously declared components hold
only when the given condition is high. The condition must have a 1-bit
unsigned integer type.</p><h4 id=operands-54>Operands:&nbsp;<a class=headline-hash href=#operands-54>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>condition</code></td><td>UInt&lt;1></td></tr></tbody></table><h3 id=firrtlwire-circtfirrtlwireop><code>firrtl.wire</code> (::circt::firrtl::WireOp)&nbsp;<a class=headline-hash href=#firrtlwire-circtfirrtlwireop>¶</a></h3><p>Define a new wire</p><p>Syntax:</p><pre><code>operation ::= `firrtl.wire` custom&lt;ImplicitSSAName&gt;(attr-dict) `:` type($result)
</code></pre><p>Declare a new wire:</p><pre><code>  %name = firrtl.wire : t1
</code></pre><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-52>Results:&nbsp;<a class=headline-hash href=#results-52>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlxor-circtfirrtlxorprimop><code>firrtl.xor</code> (::circt::firrtl::XorPrimOp)&nbsp;<a class=headline-hash href=#firrtlxor-circtfirrtlxorprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.xor` $lhs `,` $rhs  attr-dict `:`
              `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($result)
</code></pre><h4 id=operands-55>Operands:&nbsp;<a class=headline-hash href=#operands-55>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td align=center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-53>Results:&nbsp;<a class=headline-hash href=#results-53>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlxorr-circtfirrtlxorrprimop><code>firrtl.xorr</code> (::circt::firrtl::XorRPrimOp)&nbsp;<a class=headline-hash href=#firrtlxorr-circtfirrtlxorrprimop>¶</a></h3><p>Syntax:</p><pre><code>operation ::= `firrtl.xorr` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Horizontally reduce a value to one bit, using the &lsquo;xor&rsquo; operation to merge
bits. <code>xorr(x)</code> is equivalent to <code>popcount(concat(x, 1b0)) & 1</code>. As such,
it returns 0 for zero-bit-wide operands.</p><h4 id=operands-56>Operands:&nbsp;<a class=headline-hash href=#operands-56>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-54>Results:&nbsp;<a class=headline-hash href=#results-54>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>uint type</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/ESI/ title="'esi' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'esi' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/Handshake/ title="'handshake' Dialect">Next - 'handshake' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/ESI/>'esi' Dialect</a></li><li class=active><a href=/docs/Dialects/FIRRTL/>'firrtl' Dialect</a></li><li><a href=/docs/Dialects/Handshake/>'handshake' Dialect</a></li><li><a href=/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li><a href=/docs/Dialects/RTL/>'rtl' Dialect</a></li><li><a href=/docs/Dialects/StaticLogic/>'staticlogic' Dialect</a></li><li><a href=/docs/Dialects/SV/>'sv' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/ESI/>ESI<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/ESI/cosim/>ESI cosimulation model</a></li></ul></li><li><a href=/docs/SVPasses/></a></li><li><a href=/docs/Charter/>CIRCT Charter</a></li><li><a href=/docs/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/RationaleRTL-SV/>RTL and SV Dialect Rationale</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>