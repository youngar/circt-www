<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'esi' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.64.1"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/ESI/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://circt.llvm.org/js/bundle.js></script><script type=text/javascript src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'esi' Dialect</h1><p><nav id=TableOfContents><ul><li><a href=#type-constraint-definition>Type constraint definition</a><ul><li><a href=#an-esi-compatible-channel-port>An ESI-compatible channel port</a></li></ul></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#esidecodecapnp-circtesicapnpdecode>esi.decode.capnp (::circt::esi::CapnpDecode)</a></li><li><a href=#esiencodecapnp-circtesicapnpencode>esi.encode.capnp (::circt::esi::CapnpEncode)</a></li><li><a href=#esibuffer-circtesichannelbuffer>esi.buffer (::circt::esi::ChannelBuffer)</a></li><li><a href=#esicosim-circtesicosimendpoint>esi.cosim (::circt::esi::CosimEndpoint)</a></li><li><a href=#esistage-circtesipipelinestage>esi.stage (::circt::esi::PipelineStage)</a></li><li><a href=#esiunwrapiface-circtesiunwrapsvinterface>esi.unwrap.iface (::circt::esi::UnwrapSVInterface)</a></li><li><a href=#esiunwrapvr-circtesiunwrapvalidready>esi.unwrap.vr (::circt::esi::UnwrapValidReady)</a></li><li><a href=#esiwrapiface-circtesiwrapsvinterface>esi.wrap.iface (::circt::esi::WrapSVInterface)</a></li><li><a href=#esiwrapvr-circtesiwrapvalidready>esi.wrap.vr (::circt::esi::WrapValidReady)</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#channel-channelport>Channel (ChannelPort)</a></li></ul></li></ul></nav><h2 id=type-constraint-definition>Type constraint definition&nbsp;<a class=headline-hash href=#type-constraint-definition>¶</a></h2><h3 id=an-esi-compatible-channel-port>An ESI-compatible channel port&nbsp;<a class=headline-hash href=#an-esi-compatible-channel-port>¶</a></h3><p>An ESI port kind which models a latency-insensitive, unidirectional,
point-to-point data stream. Channels are typed (like all of ESI). Said
type can be any MLIR type, but must be lowered to something a backend
knows how to output (i.e. something emitVerilog knows about).</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>rtl<span class=p>.</span>externmodule <span class=nf>@Sender</span><span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span> <span class=p>!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span> <span class=p>{</span> <span class=nl>rtl.name =</span> <span class=s>&#34;x&#34;</span><span class=p>}</span> <span class=p>)</span>
rtl<span class=p>.</span>module <span class=nf>@Reciever</span><span class=p>(</span><span class=nv>%a</span><span class=p>:</span> <span class=p>!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span>rtl<span class=p>.</span>array<span class=p>&lt;</span><span class=m>5x</span><span class=k>i16</span><span class=p>&gt;</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
</code></pre></div><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=esidecodecapnp-circtesicapnpdecode><code>esi.decode.capnp</code> (::circt::esi::CapnpDecode)&nbsp;<a class=headline-hash href=#esidecodecapnp-circtesicapnpdecode>¶</a></h3><p>Translate bits in Cap&rsquo;nProto messages to RTL typed data</p><p>Syntax:</p><pre><code>operation ::= `esi.decode.capnp` $clk $valid $capnpBits attr-dict `:` type($capnpBits) `-&gt;` type($decodedData)
</code></pre><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clk</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>valid</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>capnpBits</code></td><td>an RTL bit array</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>decodedData</code></td><td>any type</td></tr></tbody></table><h3 id=esiencodecapnp-circtesicapnpencode><code>esi.encode.capnp</code> (::circt::esi::CapnpEncode)&nbsp;<a class=headline-hash href=#esiencodecapnp-circtesicapnpencode>¶</a></h3><p>Translate RTL typed data to Cap&rsquo;nProto</p><p>Syntax:</p><pre><code>operation ::= `esi.encode.capnp` $clk $valid $dataToEncode attr-dict `:` type($dataToEncode) `-&gt;` type($capnpBits)
</code></pre><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clk</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>valid</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>dataToEncode</code></td><td>any type</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>capnpBits</code></td><td>an RTL bit array</td></tr></tbody></table><h3 id=esibuffer-circtesichannelbuffer><code>esi.buffer</code> (::circt::esi::ChannelBuffer)&nbsp;<a class=headline-hash href=#esibuffer-circtesichannelbuffer>¶</a></h3><p>Control options for an ESI channel.</p><p>A channel buffer (<code>buffer</code>) is essentially a set of options on a channel.
It always adds at least one cycle of latency (pipeline stage) to the
channel, but this is configurable.</p><p>This operation is inserted on an ESI dataflow edge. It must exist
previous to SystemVerilog emission but can be added in a lowering pass.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%esiChan</span> <span class=p>=</span> rtl<span class=p>.</span>instance <span class=s>&#34;sender&#34;</span> <span class=nf>@Sender</span> <span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span>
<span class=c>// Allow automatic selection of options.
</span><span class=c></span><span class=nv>%bufferedChan</span> <span class=p>=</span> esi<span class=p>.</span>buffer <span class=nv>%esiChan</span> <span class=p>{</span> <span class=p>}</span> <span class=p>:</span> <span class=k>i1</span>
rtl<span class=p>.</span>instance <span class=s>&#34;recv&#34;</span> <span class=nf>@Reciever</span> <span class=p>(</span><span class=nv>%bufferedChan</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>

<span class=c>// Alternatively, specify the number of stages.
</span><span class=c></span><span class=nv>%fourStageBufferedChan</span> <span class=p>=</span> esi<span class=p>.</span>buffer <span class=nv>%esiChan</span> <span class=p>{</span> <span class=nl>stages =</span> <span class=m>4</span> <span class=p>}</span> <span class=p>:</span> <span class=k>i1</span>
</code></pre></div><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>options</code></td><td align=center>::circt::esi::ChannelBufferOptions</td><td>DictionaryAttr with field(s): &lsquo;stages&rsquo;, &lsquo;name&rsquo; (each field having its own constraints)</td></tr></tbody></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clk</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>rstn</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td></td></tr></tbody></table><h3 id=esicosim-circtesicosimendpoint><code>esi.cosim</code> (::circt::esi::CosimEndpoint)&nbsp;<a class=headline-hash href=#esicosim-circtesicosimendpoint>¶</a></h3><p>Co-simulation endpoint</p><p>Syntax:</p><pre><code>operation ::= `esi.cosim` $clk `,` $rstn `,` $send `,` $endpointID attr-dict
              `:` type($send) `-&gt;` type($recv)
</code></pre><p>A co-simulation endpoint is a connection from the simulation to some
outside process, usually a software application responsible for driving
the simulation (driver).</p><p>ESI uses a serialization protocol called Cap&rsquo;n Proto (capnp for short).
The advantage of capnp is the decoding overhead: for value types (ints,
structs, etc.) there is none! This stands in contrast to Protocol Buffers
and Bond as their messages contain metadata for each field which must be
interpreted.</p><p>The advantage of using a well-supported serialization protocol is
language support &ndash; driver applications can be written in any language
supported by the specific protocol.</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>endpointID</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clk</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>rstn</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>send</code></td><td></td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>recv</code></td><td></td></tr></tbody></table><h3 id=esistage-circtesipipelinestage><code>esi.stage</code> (::circt::esi::PipelineStage)&nbsp;<a class=headline-hash href=#esistage-circtesipipelinestage>¶</a></h3><p>An elastic buffer stage.</p><p>An individual elastic pipeline register. Generally lowered to from a
ChannelBuffer (&lsquo;buffer&rsquo;), though can be inserted anywhere to add an
additional pipeline stage. Adding individually could be useful for
late-pass latency balancing.</p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clk</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>rstn</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td></td></tr></tbody></table><h3 id=esiunwrapiface-circtesiunwrapsvinterface><code>esi.unwrap.iface</code> (::circt::esi::UnwrapSVInterface)&nbsp;<a class=headline-hash href=#esiunwrapiface-circtesiunwrapsvinterface>¶</a></h3><p>Unwrap an SV interface from an ESI port</p><p>Syntax:</p><pre><code>operation ::= `esi.unwrap.iface` $chanInput `into` $interfaceSource attr-dict `:` `(` type($chanInput) `,` type($interfaceSource) `)`
</code></pre><p>Unwrap an ESI channel into a SystemVerilog interface containing valid,
ready, and data signals.</p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>chanInput</code></td><td></td></tr><tr><td align=center><code>interfaceSource</code></td><td>sv.interface</td></tr></tbody></table><h3 id=esiunwrapvr-circtesiunwrapvalidready><code>esi.unwrap.vr</code> (::circt::esi::UnwrapValidReady)&nbsp;<a class=headline-hash href=#esiunwrapvr-circtesiunwrapvalidready>¶</a></h3><p>Unwrap a value from an ESI port</p><p>Unwrapping a value allows operations on the contained value. Unwrap the
channel along with a ready signal that you generate. Result is the data
along with a valid signal.</p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>chanInput</code></td><td></td></tr><tr><td align=center><code>ready</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>rawOutput</code></td><td>any type</td></tr><tr><td align=center><code>valid</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=esiwrapiface-circtesiwrapsvinterface><code>esi.wrap.iface</code> (::circt::esi::WrapSVInterface)&nbsp;<a class=headline-hash href=#esiwrapiface-circtesiwrapsvinterface>¶</a></h3><p>Wrap an SV interface into an ESI port</p><p>Syntax:</p><pre><code>operation ::= `esi.wrap.iface` $interfaceSink attr-dict `:` type($interfaceSink) `-&gt;` type($output)
</code></pre><p>Wrap a SystemVerilog interface into an ESI channel. Interface MUST look
like an interface produced by ESI meaning it MUST contain valid, ready,
and data signals. Any other signals will be discarded.</p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>interfaceSink</code></td><td>sv.interface</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>output</code></td><td></td></tr></tbody></table><h3 id=esiwrapvr-circtesiwrapvalidready><code>esi.wrap.vr</code> (::circt::esi::WrapValidReady)&nbsp;<a class=headline-hash href=#esiwrapvr-circtesiwrapvalidready>¶</a></h3><p>Wrap a value into an ESI port</p><p>Wrapping a value into an ESI port type allows modules to send values down
an ESI port. Wrap data with valid bit, result is the ESI channel and the
ready signal from the other end of the channel.</p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>rawInput</code></td><td>any type</td></tr><tr><td align=center><code>valid</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>chanOutput</code></td><td></td></tr><tr><td align=center><code>ready</code></td><td>1-bit signless integer</td></tr></tbody></table><h2 id=type-definition>Type definition&nbsp;<a class=headline-hash href=#type-definition>¶</a></h2><h3 id=channel-channelport><code>Channel</code> (ChannelPort)&nbsp;<a class=headline-hash href=#channel-channelport>¶</a></h3><p>An ESI-compatible channel port
An ESI port kind which models a latency-insensitive, unidirectional,
point-to-point data stream. Channels are typed (like all of ESI). Said
type can be any MLIR type, but must be lowered to something a backend
knows how to output (i.e. something emitVerilog knows about).</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>rtl<span class=p>.</span>externmodule <span class=nf>@Sender</span><span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span> <span class=p>!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span> <span class=p>{</span> <span class=nl>rtl.name =</span> <span class=s>&#34;x&#34;</span><span class=p>}</span> <span class=p>)</span>
rtl<span class=p>.</span>module <span class=nf>@Reciever</span><span class=p>(</span><span class=nv>%a</span><span class=p>:</span> <span class=p>!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span>rtl<span class=p>.</span>array<span class=p>&lt;</span><span class=m>5x</span><span class=k>i16</span><span class=p>&gt;</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
</code></pre></div><h4 id=type-parameters>Type parameters:&nbsp;<a class=headline-hash href=#type-parameters>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>inner</td><td align=center><code>ChannelPort</code></td><td></td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/ title=Dialects><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Dialects</a>
<a class="nav nav-next" href=/docs/Dialects/FIRRTL/ title="'firrtl' Dialect">Next - 'firrtl' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li class=active><a href=/docs/Dialects/ESI/>'esi' Dialect</a></li><li><a href=/docs/Dialects/FIRRTL/>'firrtl' Dialect</a></li><li><a href=/docs/Dialects/Handshake/>'handshake' Dialect</a></li><li><a href=/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li><a href=/docs/Dialects/RTL/>'rtl' Dialect</a></li><li><a href=/docs/Dialects/StaticLogic/>'staticlogic' Dialect</a></li><li><a href=/docs/Dialects/SV/>'sv' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/ESI/>ESI<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/ESI/cosim/>ESI cosimulation model</a></li></ul></li><li><a href=/docs/SVPasses/></a></li><li><a href=/docs/Charter/>CIRCT Charter</a></li><li><a href=/docs/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/RationaleRTL-SV/>RTL and SV Dialect Rationale</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>