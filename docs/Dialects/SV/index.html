<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'sv' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.64.1"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/SV/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://circt.llvm.org/js/bundle.js></script><script type=text/javascript src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'sv' Dialect</h1><p>Types and operations for SV dialect
This dialect defines the <code>sv</code> dialect, which represents various
SystemVerilog-specific constructs in an AST-like representation.</p><p><nav id=TableOfContents><ul><li><a href=#type-constraint-definition>Type constraint definition</a><ul><li><a href=#systemverilog-interface-type-pointing-to-an-interfaceop>SystemVerilog interface type pointing to an InterfaceOp</a></li><li><a href=#systemverilog-type-pointing-to-an-interfacemodportop>SystemVerilog type pointing to an InterfaceModportOp</a></li></ul></li><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#svalias-circtsvaliasop>sv.alias (::circt::sv::AliasOp)</a></li><li><a href=#svalwaysff-circtsvalwaysffop>sv.alwaysff (::circt::sv::AlwaysFFOp)</a></li><li><a href=#svalways-circtsvalwaysop>sv.always (::circt::sv::AlwaysOp)</a></li><li><a href=#svarray_index_inout-circtsvarrayindexinoutop>sv.array_index_inout (::circt::sv::ArrayIndexInOutOp)</a></li><li><a href=#svassert-circtsvassertop>sv.assert (::circt::sv::AssertOp)</a></li><li><a href=#svinterfacesignalassign-circtsvassigninterfacesignalop>sv.interface.signal.assign (::circt::sv::AssignInterfaceSignalOp)</a></li><li><a href=#svassume-circtsvassumeop>sv.assume (::circt::sv::AssumeOp)</a></li><li><a href=#svbpassign-circtsvbpassignop>sv.bpassign (::circt::sv::BPAssignOp)</a></li><li><a href=#svconnect-circtsvconnectop>sv.connect (::circt::sv::ConnectOp)</a></li><li><a href=#svcover-circtsvcoverop>sv.cover (::circt::sv::CoverOp)</a></li><li><a href=#svfwrite-circtsvfwriteop>sv.fwrite (::circt::sv::FWriteOp)</a></li><li><a href=#svfatal-circtsvfatalop>sv.fatal (::circt::sv::FatalOp)</a></li><li><a href=#svfinish-circtsvfinishop>sv.finish (::circt::sv::FinishOp)</a></li><li><a href=#svmodportget-circtsvgetmodportop>sv.modport.get (::circt::sv::GetModportOp)</a></li><li><a href=#svifdef-circtsvifdefop>sv.ifdef (::circt::sv::IfDefOp)</a></li><li><a href=#svif-circtsvifop>sv.if (::circt::sv::IfOp)</a></li><li><a href=#svinitial-circtsvinitialop>sv.initial (::circt::sv::InitialOp)</a></li><li><a href=#svinterfaceinstance-circtsvinterfaceinstanceop>sv.interface.instance (::circt::sv::InterfaceInstanceOp)</a></li><li><a href=#svinterfacemodport-circtsvinterfacemodportop>sv.interface.modport (::circt::sv::InterfaceModportOp)</a></li><li><a href=#svinterface-circtsvinterfaceop>sv.interface (::circt::sv::InterfaceOp)</a></li><li><a href=#svinterfacesignal-circtsvinterfacesignalop>sv.interface.signal (::circt::sv::InterfaceSignalOp)</a></li><li><a href=#svpassign-circtsvpassignop>sv.passign (::circt::sv::PAssignOp)</a></li><li><a href=#svread_inout-circtsvreadinoutop>sv.read_inout (::circt::sv::ReadInOutOp)</a></li><li><a href=#svinterfacesignalread-circtsvreadinterfacesignalop>sv.interface.signal.read (::circt::sv::ReadInterfaceSignalOp)</a></li><li><a href=#svreg-circtsvregop>sv.reg (::circt::sv::RegOp)</a></li><li><a href=#svtextual_value-circtsvtextualvalueop>sv.textual_value (::circt::sv::TextualValueOp)</a></li><li><a href=#svtype_decl_terminator-circtsvtypedeclterminatorop>sv.type_decl_terminator (::circt::sv::TypeDeclTerminatorOp)</a></li><li><a href=#svverbatim-circtsvverbatimop>sv.verbatim (::circt::sv::VerbatimOp)</a></li><li><a href=#svwire-circtsvwireop>sv.wire (::circt::sv::WireOp)</a></li><li><a href=#svyield-circtsvyieldop>sv.yield (::circt::sv::YieldOp)</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#interfacetype-interfacetype>InterfaceType (InterfaceType)</a></li><li><a href=#modporttype-modporttype>ModportType (ModportType)</a></li></ul></li></ul></nav><h2 id=type-constraint-definition>Type constraint definition&nbsp;<a class=headline-hash href=#type-constraint-definition>¶</a></h2><h3 id=systemverilog-interface-type-pointing-to-an-interfaceop>SystemVerilog interface type pointing to an InterfaceOp&nbsp;<a class=headline-hash href=#systemverilog-interface-type-pointing-to-an-interfaceop>¶</a></h3><p>A MLIR type for the SV dialect&rsquo;s <code>InterfaceOp</code> to allow instances in any
dialect with an open type system. Points at the InterfaceOp which defines
the SystemVerilog interface.</p><h3 id=systemverilog-type-pointing-to-an-interfacemodportop>SystemVerilog type pointing to an InterfaceModportOp&nbsp;<a class=headline-hash href=#systemverilog-type-pointing-to-an-interfacemodportop>¶</a></h3><p>A MLIR type for the SV dialect&rsquo;s <code>InterfaceModportOp</code> to allow
interactions with any open type system dialect. Points at the
InterfaceModportOp which defines the SystemVerilog interface&rsquo;s modport.</p><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=svalias-circtsvaliasop><code>sv.alias</code> (::circt::sv::AliasOp)&nbsp;<a class=headline-hash href=#svalias-circtsvaliasop>¶</a></h3><p>SystemVerilog &lsquo;alias&rsquo; statement</p><p>Syntax:</p><pre><code>operation ::= `sv.alias` $operands attr-dict `:` type($operands)
</code></pre><p>An alias statement declares multiple names for the same physical net, or
bits within a net. Aliases always have at least two operands.</p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>InOutType</td></tr></tbody></table><h3 id=svalwaysff-circtsvalwaysffop><code>sv.alwaysff</code> (::circt::sv::AlwaysFFOp)&nbsp;<a class=headline-hash href=#svalwaysff-circtsvalwaysffop>¶</a></h3><p>&lsquo;alwaysff @&rsquo; block with optional reset</p><p>Syntax:</p><pre><code>operation ::= `sv.alwaysff` `(` $clockEdge $clock `)` $bodyBlk
              ( `(` $resetStyle `:` $resetEdge^ $reset `)` $resetBlk )? attr-dict
</code></pre><p>alwaysff blocks represent always_ff verilog nodes, which enforce inference
of registers. This block takes a clock signal and edge sensitivity and
reset type. If the reset type is anything but &lsquo;noreset&rsquo;, the block takes a
reset signal, reset sensitivity, and reset block. Appropriate if conditions
are generated in the output code based on the reset type. A negative-edge,
asynchronous reset will check the inverse of the reset condition
(if (!reset) begin resetblock end) to match the sensitivity.</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clockEdge</code></td><td align=center>::mlir::IntegerAttr</td><td>edge control trigger</td></tr><tr><td align=center><code>resetStyle</code></td><td align=center>::mlir::IntegerAttr</td><td>reset type</td></tr><tr><td align=center><code>resetEdge</code></td><td align=center>::mlir::IntegerAttr</td><td>edge control trigger</td></tr></tbody></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clock</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>reset</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=svalways-circtsvalwaysop><code>sv.always</code> (::circt::sv::AlwaysOp)&nbsp;<a class=headline-hash href=#svalways-circtsvalwaysop>¶</a></h3><p>&lsquo;always @&rsquo; block</p><p>Syntax:</p><pre><code>operation ::= `sv.always` custom&lt;EventList&gt;($events, $clocks) $body attr-dict
</code></pre><p>See SV Spec 9.2, and 9.4.2.2.</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>events</code></td><td align=center>::mlir::ArrayAttr</td><td>events</td></tr></tbody></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>clocks</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=svarray_index_inout-circtsvarrayindexinoutop><code>sv.array_index_inout</code> (::circt::sv::ArrayIndexInOutOp)&nbsp;<a class=headline-hash href=#svarray_index_inout-circtsvarrayindexinoutop>¶</a></h3><p>Index an inout memory to produce an inout element</p><p>Syntax:</p><pre><code>operation ::= `sv.array_index_inout` $input`[`$index`]` attr-dict `:` type($input) `,` type($index)
</code></pre><p>See SV Spec 11.5.2.</p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>an inout type with array element</td></tr><tr><td align=center><code>index</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svassert-circtsvassertop><code>sv.assert</code> (::circt::sv::AssertOp)&nbsp;<a class=headline-hash href=#svassert-circtsvassertop>¶</a></h3><p>immediate assertion statement</p><p>Syntax:</p><pre><code>operation ::= `sv.assert` attr-dict $predicate `:` type($predicate)
</code></pre><p>Assert that a specific condition is always true.</p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>predicate</code></td><td>any type</td></tr></tbody></table><h3 id=svinterfacesignalassign-circtsvassigninterfacesignalop><code>sv.interface.signal.assign</code> (::circt::sv::AssignInterfaceSignalOp)&nbsp;<a class=headline-hash href=#svinterfacesignalassign-circtsvassigninterfacesignalop>¶</a></h3><p>Assign an interfaces signal to some other signal.</p><p>Syntax:</p><pre><code>operation ::= `sv.interface.signal.assign` $iface `(` custom&lt;IfaceTypeAndSignal&gt;(type($iface), $signalName) `)`
              `=` $rhs attr-dict `:` type($rhs)
</code></pre><p>Use this to continuously assign a signal inside an interface to a
value or other signal.</p><pre><code>  sv.interface.signal.assign %iface(@handshake_example::@data) 
    = %zero32 : i32
</code></pre><p>Would result in the following SystemVerilog:</p><pre><code>  assign iface.data = zero32;
</code></pre><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>signalName</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>iface</code></td><td>SystemVerilog interface type pointing to an InterfaceOp</td></tr><tr><td align=center><code>rhs</code></td><td>any type</td></tr></tbody></table><h3 id=svassume-circtsvassumeop><code>sv.assume</code> (::circt::sv::AssumeOp)&nbsp;<a class=headline-hash href=#svassume-circtsvassumeop>¶</a></h3><p>assume property statement</p><p>Syntax:</p><pre><code>operation ::= `sv.assume` attr-dict $property `:` type($property)
</code></pre><p>Assume that a specific property is always true.</p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>property</code></td><td>any type</td></tr></tbody></table><h3 id=svbpassign-circtsvbpassignop><code>sv.bpassign</code> (::circt::sv::BPAssignOp)&nbsp;<a class=headline-hash href=#svbpassign-circtsvbpassignop>¶</a></h3><p>Blocking procedural assignment</p><p>Syntax:</p><pre><code>operation ::= `sv.bpassign` $dest `,` $src  attr-dict `:` type($src)
</code></pre><p>A SystemVerilog blocking procedural assignment statement &lsquo;x = y;'. These
occur in initial, always, task, and function blocks. The statement is
executed before any following statements are. See SV Spec 10.4.1.</p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>InOutType</td></tr><tr><td align=center><code>src</code></td><td>a valid inout element</td></tr></tbody></table><h3 id=svconnect-circtsvconnectop><code>sv.connect</code> (::circt::sv::ConnectOp)&nbsp;<a class=headline-hash href=#svconnect-circtsvconnectop>¶</a></h3><p>Connect two signals</p><p>Syntax:</p><pre><code>operation ::= `sv.connect` $dest `,` $src  attr-dict `:` type($src)
</code></pre><p>Connect Operation:</p><pre><code>  sv.connect %dest, %src : t1
</code></pre><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>InOutType</td></tr><tr><td align=center><code>src</code></td><td>a known primitive element</td></tr></tbody></table><h3 id=svcover-circtsvcoverop><code>sv.cover</code> (::circt::sv::CoverOp)&nbsp;<a class=headline-hash href=#svcover-circtsvcoverop>¶</a></h3><p>functional coverage statement</p><p>Syntax:</p><pre><code>operation ::= `sv.cover` attr-dict $property `:` type($property)
</code></pre><p>Assert that a specific property happens during the course of execution.</p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>property</code></td><td>any type</td></tr></tbody></table><h3 id=svfwrite-circtsvfwriteop><code>sv.fwrite</code> (::circt::sv::FWriteOp)&nbsp;<a class=headline-hash href=#svfwrite-circtsvfwriteop>¶</a></h3><p>&lsquo;$fwrite&rsquo; statement</p><p>Syntax:</p><pre><code>operation ::= `sv.fwrite` $string attr-dict (`(` $operands^ `)` `:` type($operands))?
</code></pre><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>string</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svfatal-circtsvfatalop><code>sv.fatal</code> (::circt::sv::FatalOp)&nbsp;<a class=headline-hash href=#svfatal-circtsvfatalop>¶</a></h3><p>&lsquo;$fatal&rsquo; statement</p><p>Syntax:</p><pre><code>operation ::= `sv.fatal` attr-dict
</code></pre><p>Run-time fatal assertion error.</p><h3 id=svfinish-circtsvfinishop><code>sv.finish</code> (::circt::sv::FinishOp)&nbsp;<a class=headline-hash href=#svfinish-circtsvfinishop>¶</a></h3><p>&lsquo;$finish&rsquo; statement</p><p>Syntax:</p><pre><code>operation ::= `sv.finish` attr-dict
</code></pre><p>Finishes a simulation and exits the simulation process.</p><h3 id=svmodportget-circtsvgetmodportop><code>sv.modport.get</code> (::circt::sv::GetModportOp)&nbsp;<a class=headline-hash href=#svmodportget-circtsvgetmodportop>¶</a></h3><p>Get a modport out of an interface instance</p><p>Syntax:</p><pre><code>operation ::= `sv.modport.get` $iface $field attr-dict `:` type($iface) `-&gt;` type($result)
</code></pre><p>Use this to extract a modport view to an instantiated interface. For
example, to get the &lsquo;dataflow_in&rsquo; modport on the &lsquo;handshake_example&rsquo;
interface:</p><pre><code>%ifaceModport = sv.modport.get @dataflow_in %iface :
  !sv.interface&lt;@handshake_example&gt; -&gt;
  !sv.modport&lt;@handshake_example::@dataflow_in&gt;
</code></pre><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>field</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>iface</code></td><td>SystemVerilog interface type pointing to an InterfaceOp</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>SystemVerilog type pointing to an InterfaceModportOp</td></tr></tbody></table><h3 id=svifdef-circtsvifdefop><code>sv.ifdef</code> (::circt::sv::IfDefOp)&nbsp;<a class=headline-hash href=#svifdef-circtsvifdefop>¶</a></h3><p>&lsquo;ifdef MACRO&rsquo; block</p><p>Syntax:</p><pre><code>operation ::= `sv.ifdef` $cond $thenRegion (`else` $elseRegion^)? attr-dict
</code></pre><p>This operation is an #ifdef block, or an #ifndef block if <code>string</code> starts
with a <code>!</code> character.</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>cond</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=svif-circtsvifop><code>sv.if</code> (::circt::sv::IfOp)&nbsp;<a class=headline-hash href=#svif-circtsvifop>¶</a></h3><p>&lsquo;if (cond)&rsquo; block</p><p>Syntax:</p><pre><code>operation ::= `sv.if` $cond $thenRegion (`else` $elseRegion^)? attr-dict
</code></pre><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>cond</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=svinitial-circtsvinitialop><code>sv.initial</code> (::circt::sv::InitialOp)&nbsp;<a class=headline-hash href=#svinitial-circtsvinitialop>¶</a></h3><p>&lsquo;initial&rsquo; block</p><p>Syntax:</p><pre><code>operation ::= `sv.initial` $body attr-dict
</code></pre><p>See SV Spec 9.2.1.</p><h3 id=svinterfaceinstance-circtsvinterfaceinstanceop><code>sv.interface.instance</code> (::circt::sv::InterfaceInstanceOp)&nbsp;<a class=headline-hash href=#svinterfaceinstance-circtsvinterfaceinstanceop>¶</a></h3><p>Instantiate an interface</p><p>Syntax:</p><pre><code>operation ::= `sv.interface.instance` attr-dict `:` type($result)
</code></pre><p>Use this to declare an instance of an interface:</p><pre><code>%iface = sv.interface.instance : !sv.interface&lt;@handshake_example&gt;
</code></pre><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>SystemVerilog interface type pointing to an InterfaceOp</td></tr></tbody></table><h3 id=svinterfacemodport-circtsvinterfacemodportop><code>sv.interface.modport</code> (::circt::sv::InterfaceModportOp)&nbsp;<a class=headline-hash href=#svinterfacemodport-circtsvinterfacemodportop>¶</a></h3><p>Operation to define a SystemVerilog modport for interfaces</p><p>Syntax:</p><pre><code>operation ::= `sv.interface.modport` attr-dict $sym_name custom&lt;ModportStructs&gt;($ports)
</code></pre><p>This operation defines a named modport within an interface. Its name is a
symbol that can be looked up inside its parent interface. There is an array
of structs that contains two fields: an enum to indicate the direction of
the signal in the modport, and a symbol reference to refer to the signal.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>sv<span class=p>.</span>interface<span class=p>.</span>modport <span class=nf>@input_port</span> <span class=p>(</span><span class=s>&#34;input&#34;</span> <span class=nf>@data</span><span class=p>)</span>
sv<span class=p>.</span>interface<span class=p>.</span>modport <span class=nf>@output_port</span> <span class=p>(</span><span class=s>&#34;output&#34;</span> <span class=nf>@data</span><span class=p>)</span>
</code></pre></div><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sym_name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>ports</code></td><td align=center>::mlir::ArrayAttr</td><td>array of modport structs</td></tr></tbody></table><h3 id=svinterface-circtsvinterfaceop><code>sv.interface</code> (::circt::sv::InterfaceOp)&nbsp;<a class=headline-hash href=#svinterface-circtsvinterfaceop>¶</a></h3><p>Operation to define a SystemVerilog interface</p><p>Syntax:</p><pre><code>operation ::= `sv.interface` attr-dict $sym_name $body
</code></pre><p>This operation defines a named interface. Its name is a symbol that can
be looked up when declared inside a SymbolTable operation. This operation is
also a SymbolTable itself, so the symbols in its region can be looked up.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>sv<span class=p>.</span>interface <span class=nf>@myinterface</span> <span class=p>{</span>
  sv<span class=p>.</span>interface<span class=p>.</span>signal <span class=nf>@data</span> <span class=p>:</span> <span class=k>i32</span>
  sv<span class=p>.</span>interface<span class=p>.</span>modport <span class=nf>@input_port</span> <span class=p>(</span><span class=s>&#34;input&#34;</span> <span class=nf>@data</span><span class=p>)</span>
  sv<span class=p>.</span>interface<span class=p>.</span>modport <span class=nf>@output_port</span> <span class=p>(</span><span class=s>&#34;output&#34;</span> <span class=nf>@data</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sym_name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=svinterfacesignal-circtsvinterfacesignalop><code>sv.interface.signal</code> (::circt::sv::InterfaceSignalOp)&nbsp;<a class=headline-hash href=#svinterfacesignal-circtsvinterfacesignalop>¶</a></h3><p>Operation to define a SystemVerilog signal for interfaces</p><p>Syntax:</p><pre><code>operation ::= `sv.interface.signal` attr-dict $sym_name `:` $type
</code></pre><p>This operation defines a named signal within an interface. Its type is
specified in an attribute, and currently supports IntegerTypes.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>sv<span class=p>.</span>interface<span class=p>.</span>signal <span class=nf>@data</span> <span class=p>:</span> <span class=k>i32</span>
</code></pre></div><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sym_name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>type</code></td><td align=center>::mlir::TypeAttr</td><td>Any SV/RTL type</td></tr></tbody></table><h3 id=svpassign-circtsvpassignop><code>sv.passign</code> (::circt::sv::PAssignOp)&nbsp;<a class=headline-hash href=#svpassign-circtsvpassignop>¶</a></h3><p>Nonblocking procedural assignment</p><p>Syntax:</p><pre><code>operation ::= `sv.passign` $dest `,` $src  attr-dict `:` type($src)
</code></pre><p>A SystemVerilog nonblocking procedural assignment statement &lsquo;x &lt;= y;'.
These occur in initial, always, task, and function blocks. The statement
can be scheduled without blocking procedural flow. See SV Spec 10.4.2.</p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>InOutType</td></tr><tr><td align=center><code>src</code></td><td>a valid inout element</td></tr></tbody></table><h3 id=svread_inout-circtsvreadinoutop><code>sv.read_inout</code> (::circt::sv::ReadInOutOp)&nbsp;<a class=headline-hash href=#svread_inout-circtsvreadinoutop>¶</a></h3><p>Get the value of from something of inout type (e.g. a wire or inout port) as the value itself.</p><p>Syntax:</p><pre><code>operation ::= `sv.read_inout` $input attr-dict `:` type($input)
</code></pre><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>input</code></td><td>InOutType</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>a known primitive element</td></tr></tbody></table><h3 id=svinterfacesignalread-circtsvreadinterfacesignalop><code>sv.interface.signal.read</code> (::circt::sv::ReadInterfaceSignalOp)&nbsp;<a class=headline-hash href=#svinterfacesignalread-circtsvreadinterfacesignalop>¶</a></h3><p>Access the data in an interface&rsquo;s signal.</p><p>Syntax:</p><pre><code>operation ::= `sv.interface.signal.read` $iface `(` custom&lt;IfaceTypeAndSignal&gt;(type($iface), $signalName) `)`
              attr-dict `:` type($signalData)
</code></pre><p>This is an expression to access a signal inside of an interface.</p><pre><code>  %ifaceData = sv.interface.signal.read %iface
      (@handshake_example::@data) : i32
</code></pre><p>Could result in the following SystemVerilog:</p><pre><code>  wire [31:0] ifaceData = iface.data;
</code></pre><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>signalName</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>iface</code></td><td>SystemVerilog interface type pointing to an InterfaceOp</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>signalData</code></td><td>any type</td></tr></tbody></table><h3 id=svreg-circtsvregop><code>sv.reg</code> (::circt::sv::RegOp)&nbsp;<a class=headline-hash href=#svreg-circtsvregop>¶</a></h3><p>Define a new <code>reg</code> in SystemVerilog</p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svtextual_value-circtsvtextualvalueop><code>sv.textual_value</code> (::circt::sv::TextualValueOp)&nbsp;<a class=headline-hash href=#svtextual_value-circtsvtextualvalueop>¶</a></h3><p>Expression that expands to a value given SystemVerilog text</p><p>Syntax:</p><pre><code>operation ::= `sv.textual_value` $string attr-dict `:` type($result)
</code></pre><p>This operation produces a typed value expressed by a string of
SystemVerilog. This can be used to access macros and other values that are
only sensible as Verilog text.</p><p>The text string is expected to have the highest precedence, so it should
be parenthesized if it isn&rsquo;t a single token.</p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>string</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>signless integer</td></tr></tbody></table><h3 id=svtype_decl_terminator-circtsvtypedeclterminatorop><code>sv.type_decl_terminator</code> (::circt::sv::TypeDeclTerminatorOp)&nbsp;<a class=headline-hash href=#svtype_decl_terminator-circtsvtypedeclterminatorop>¶</a></h3><p>Terminator for type declaration operations</p><h3 id=svverbatim-circtsvverbatimop><code>sv.verbatim</code> (::circt::sv::VerbatimOp)&nbsp;<a class=headline-hash href=#svverbatim-circtsvverbatimop>¶</a></h3><p>sv.verbatim allows operand substitutions with {{0}} syntax.</p><p>Syntax:</p><pre><code>operation ::= `sv.verbatim` $string attr-dict (`(` $operands^ `)` `:` type($operands))?
</code></pre><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>string</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svwire-circtsvwireop><code>sv.wire</code> (::circt::sv::WireOp)&nbsp;<a class=headline-hash href=#svwire-circtsvwireop>¶</a></h3><p>Define a new wire</p><p>Syntax:</p><pre><code>operation ::= `sv.wire` custom&lt;ImplicitSSAName&gt;(attr-dict) `:` type($result)
</code></pre><p>Declare a new wire:</p><pre><code>  %name = sv.wire : !rtl.inout&lt;t1&gt;
</code></pre><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svyield-circtsvyieldop><code>sv.yield</code> (::circt::sv::YieldOp)&nbsp;<a class=headline-hash href=#svyield-circtsvyieldop>¶</a></h3><p>terminator for control-flow operation regions</p><p>Syntax:</p><pre><code>operation ::= `sv.yield` attr-dict
</code></pre><h2 id=type-definition>Type definition&nbsp;<a class=headline-hash href=#type-definition>¶</a></h2><h3 id=interfacetype-interfacetype><code>InterfaceType</code> (InterfaceType)&nbsp;<a class=headline-hash href=#interfacetype-interfacetype>¶</a></h3><p>SystemVerilog interface type pointing to an InterfaceOp
A MLIR type for the SV dialect&rsquo;s <code>InterfaceOp</code> to allow instances in any
dialect with an open type system. Points at the InterfaceOp which defines
the SystemVerilog interface.</p><h4 id=type-parameters>Type parameters:&nbsp;<a class=headline-hash href=#type-parameters>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>interface</td><td align=center><code>InterfaceType</code></td><td></td></tr></tbody></table><h3 id=modporttype-modporttype><code>ModportType</code> (ModportType)&nbsp;<a class=headline-hash href=#modporttype-modporttype>¶</a></h3><p>SystemVerilog type pointing to an InterfaceModportOp
A MLIR type for the SV dialect&rsquo;s <code>InterfaceModportOp</code> to allow
interactions with any open type system dialect. Points at the
InterfaceModportOp which defines the SystemVerilog interface&rsquo;s modport.</p><h4 id=type-parameters-1>Type parameters:&nbsp;<a class=headline-hash href=#type-parameters-1>¶</a></h4><table><thead><tr><th align=center>Parameter</th><th align=center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td align=center>modport</td><td align=center><code>ModportType</code></td><td></td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/StaticLogic/ title="'staticlogic' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'staticlogic' Dialect</a>
<a class="nav nav-next" href=/docs/ESI/ title=ESI>Next - ESI <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/ESI/>'esi' Dialect</a></li><li><a href=/docs/Dialects/FIRRTL/>'firrtl' Dialect</a></li><li><a href=/docs/Dialects/Handshake/>'handshake' Dialect</a></li><li><a href=/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li><a href=/docs/Dialects/RTL/>'rtl' Dialect</a></li><li><a href=/docs/Dialects/StaticLogic/>'staticlogic' Dialect</a></li><li class=active><a href=/docs/Dialects/SV/>'sv' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/ESI/>ESI<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/ESI/cosim/>ESI cosimulation model</a></li></ul></li><li><a href=/docs/SVPasses/></a></li><li><a href=/docs/Charter/>CIRCT Charter</a></li><li><a href=/docs/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/RationaleRTL-SV/>RTL and SV Dialect Rationale</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>