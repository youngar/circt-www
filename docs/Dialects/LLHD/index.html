<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'llhd' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.64.1"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/LLHD/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://circt.llvm.org/js/bundle.js></script><script type=text/javascript src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'llhd' Dialect</h1><p>A low-level hardware description dialect in MLIR.</p><p><nav id=TableOfContents><ul><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#llhdand-circtllhdandop>llhd.and (::circt::llhd::AndOp)</a></li><li><a href=#llhdarray-circtllhdarrayop>llhd.array (::circt::llhd::ArrayOp)</a></li><li><a href=#llhdarray_uniform-circtllhdarrayuniformop>llhd.array_uniform (::circt::llhd::ArrayUniformOp)</a></li><li><a href=#llhdconst-circtllhdconstop>llhd.const (::circt::llhd::ConstOp)</a></li><li><a href=#llhddrv-circtllhddrvop>llhd.drv (::circt::llhd::DrvOp)</a></li><li><a href=#llhddyn_extract_element-circtllhddynextractelementop>llhd.dyn_extract_element (::circt::llhd::DynExtractElementOp)</a></li><li><a href=#llhddyn_extract_slice-circtllhddynextractsliceop>llhd.dyn_extract_slice (::circt::llhd::DynExtractSliceOp)</a></li><li><a href=#llhdentity-circtllhdentityop>llhd.entity (::circt::llhd::EntityOp)</a></li><li><a href=#llhdeq-circtllhdeqop>llhd.eq (::circt::llhd::EqOp)</a></li><li><a href=#llhdextract_element-circtllhdextractelementop>llhd.extract_element (::circt::llhd::ExtractElementOp)</a></li><li><a href=#llhdextract_slice-circtllhdextractsliceop>llhd.extract_slice (::circt::llhd::ExtractSliceOp)</a></li><li><a href=#llhdhalt-circtllhdhaltop>llhd.halt (::circt::llhd::HaltOp)</a></li><li><a href=#llhdinsert_element-circtllhdinsertelementop>llhd.insert_element (::circt::llhd::InsertElementOp)</a></li><li><a href=#llhdinsert_slice-circtllhdinsertsliceop>llhd.insert_slice (::circt::llhd::InsertSliceOp)</a></li><li><a href=#llhdinst-circtllhdinstop>llhd.inst (::circt::llhd::InstOp)</a></li><li><a href=#llhdload-circtllhdloadop>llhd.load (::circt::llhd::LoadOp)</a></li><li><a href=#llhdneg-circtllhdnegop>llhd.neg (::circt::llhd::NegOp)</a></li><li><a href=#llhdneq-circtllhdneqop>llhd.neq (::circt::llhd::NeqOp)</a></li><li><a href=#llhdnot-circtllhdnotop>llhd.not (::circt::llhd::NotOp)</a></li><li><a href=#llhdor-circtllhdorop>llhd.or (::circt::llhd::OrOp)</a></li><li><a href=#llhdprb-circtllhdprbop>llhd.prb (::circt::llhd::PrbOp)</a></li><li><a href=#llhdproc-circtllhdprocop>llhd.proc (::circt::llhd::ProcOp)</a></li><li><a href=#llhdreg-circtllhdregop>llhd.reg (::circt::llhd::RegOp)</a></li><li><a href=#llhdsmod-circtllhdsmodop>llhd.smod (::circt::llhd::SModOp)</a></li><li><a href=#llhdshl-circtllhdshlop>llhd.shl (::circt::llhd::ShlOp)</a></li><li><a href=#llhdshr-circtllhdshrop>llhd.shr (::circt::llhd::ShrOp)</a></li><li><a href=#llhdsig-circtllhdsigop>llhd.sig (::circt::llhd::SigOp)</a></li><li><a href=#llhdstore-circtllhdstoreop>llhd.store (::circt::llhd::StoreOp)</a></li><li><a href=#llhdterminator-circtllhdterminatorop>llhd.terminator (::circt::llhd::TerminatorOp)</a></li><li><a href=#llhdtuple-circtllhdtupleop>llhd.tuple (::circt::llhd::TupleOp)</a></li><li><a href=#llhdvar-circtllhdvarop>llhd.var (::circt::llhd::VarOp)</a></li><li><a href=#llhdwait-circtllhdwaitop>llhd.wait (::circt::llhd::WaitOp)</a></li><li><a href=#llhdxor-circtllhdxorop>llhd.xor (::circt::llhd::XorOp)</a></li></ul></li></ul></nav><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=llhdand-circtllhdandop><code>llhd.and</code> (::circt::llhd::AndOp)&nbsp;<a class=headline-hash href=#llhdand-circtllhdandop>¶</a></h3><p>Bitwise AND</p><p>Takes two integers of the same width or two nine-valued-logic (IEEE 1164)
values of the same width as input. Calculates the bitwise AND. The
result is always of the exact same type as the two inputs.</p><p>Syntax:</p><pre><code>and-op ::= ssa-id `=` `llhd.and` ssa-lhs `,` ssa-rhs attr-dict `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span>and <span class=nv>%0</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</code></pre></div><p>Truth Table for integers:</p><table><thead><tr><th align=center><code>and</code></th><th align=center>0</th><th align=center>1</th></tr></thead><tbody><tr><td align=center>0</td><td align=center>0</td><td align=center>0</td></tr><tr><td align=center>1</td><td align=center>0</td><td align=center>1</td></tr></tbody></table><p>Truth Table for nine-valued logic:</p><table><thead><tr><th align=center><code>and</code></th><th align=center>U</th><th align=center>X</th><th align=center>0</th><th align=center>1</th><th align=center>Z</th><th align=center>W</th><th align=center>L</th><th align=center>H</th><th align=center>-</th></tr></thead><tbody><tr><td align=center>U</td><td align=center>U</td><td align=center>U</td><td align=center>0</td><td align=center>U</td><td align=center>U</td><td align=center>U</td><td align=center>0</td><td align=center>U</td><td align=center>U</td></tr><tr><td align=center>X</td><td align=center>U</td><td align=center>X</td><td align=center>0</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>0</td><td align=center>X</td><td align=center>X</td></tr><tr><td align=center>0</td><td align=center>0</td><td align=center>0</td><td align=center>0</td><td align=center>0</td><td align=center>0</td><td align=center>0</td><td align=center>0</td><td align=center>0</td><td align=center>0</td></tr><tr><td align=center>1</td><td align=center>U</td><td align=center>X</td><td align=center>0</td><td align=center>1</td><td align=center>X</td><td align=center>X</td><td align=center>0</td><td align=center>1</td><td align=center>X</td></tr><tr><td align=center>Z</td><td align=center>U</td><td align=center>X</td><td align=center>0</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>0</td><td align=center>X</td><td align=center>X</td></tr><tr><td align=center>W</td><td align=center>U</td><td align=center>X</td><td align=center>0</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>0</td><td align=center>X</td><td align=center>X</td></tr><tr><td align=center>L</td><td align=center>0</td><td align=center>0</td><td align=center>0</td><td align=center>0</td><td align=center>0</td><td align=center>0</td><td align=center>0</td><td align=center>0</td><td align=center>0</td></tr><tr><td align=center>H</td><td align=center>U</td><td align=center>X</td><td align=center>0</td><td align=center>1</td><td align=center>X</td><td align=center>X</td><td align=center>0</td><td align=center>1</td><td align=center>X</td></tr><tr><td align=center>-</td><td align=center>U</td><td align=center>X</td><td align=center>0</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>0</td><td align=center>X</td><td align=center>X</td></tr></tbody></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless integer</td></tr><tr><td align=center><code>rhs</code></td><td>signless integer</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>signless integer</td></tr></tbody></table><h3 id=llhdarray-circtllhdarrayop><code>llhd.array</code> (::circt::llhd::ArrayOp)&nbsp;<a class=headline-hash href=#llhdarray-circtllhdarrayop>¶</a></h3><p>Create an array from a list of values.</p><p>Syntax:</p><pre><code>operation ::= `llhd.array` $values attr-dict `:` type($result)
</code></pre><p>The <code>llhd.array</code> operation allows to create an array from a list of
SSA-values.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%c1</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%c2</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>2</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%c3</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>3</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%array</span> <span class=p>=</span> llhd<span class=p>.</span>array <span class=nv>%c1</span><span class=p>,</span> <span class=nv>%c2</span><span class=p>,</span> <span class=nv>%c3</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span>
<span class=nv>%elem</span> <span class=p>=</span> llhd<span class=p>.</span>extract_element <span class=nv>%array</span><span class=p>,</span> <span class=m>0</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</code></pre></div><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>values</code></td><td>any type</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>LLHD array type</td></tr></tbody></table><h3 id=llhdarray_uniform-circtllhdarrayuniformop><code>llhd.array_uniform</code> (::circt::llhd::ArrayUniformOp)&nbsp;<a class=headline-hash href=#llhdarray_uniform-circtllhdarrayuniformop>¶</a></h3><p>Create a uniform array from an initialization value.</p><p>Syntax:</p><pre><code>operation ::= `llhd.array_uniform` $init attr-dict `:` type($result)
</code></pre><p>The <code>llhd.array_uniform</code> operation allows to create an LLHD array from a
single SSA-value used as initialization for all elements.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%init</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%array</span> <span class=p>=</span> llhd<span class=p>.</span>array_uniform <span class=nv>%init</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>init</code></td><td>any type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>LLHD array type</td></tr></tbody></table><h3 id=llhdconst-circtllhdconstop><code>llhd.const</code> (::circt::llhd::ConstOp)&nbsp;<a class=headline-hash href=#llhdconst-circtllhdconstop>¶</a></h3><p>Introduce a new constant.</p><p>The <code>llhd.const</code> instruction introduces a new constant value as an
SSA-operator.
Legal types are integers and time. Note: Signals
are not legal to define using <code>llhd.const</code>, use the <code>llhd.sig</code>
instruction for that.</p><p>Syntax:</p><pre><code>const-op ::= ssa-id `=`
  `llhd.const` attribute-value attr-dict `:` result-type
</code></pre><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>1</span> <span class=p>:</span> <span class=k>i64</span>
<span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=nv>#llhd.time</span><span class=p>&lt;</span><span class=m>1</span>ns<span class=p>,</span> <span class=m>2</span>d<span class=p>,</span> <span class=m>3</span>d<span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>time
</code></pre></div><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td align=center>::mlir::Attribute</td><td>any attribute</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>out</code></td><td>signless integer or LLHD time type</td></tr></tbody></table><h3 id=llhddrv-circtllhddrvop><code>llhd.drv</code> (::circt::llhd::DrvOp)&nbsp;<a class=headline-hash href=#llhddrv-circtllhddrvop>¶</a></h3><p>Drive a value into a signal.</p><p>Syntax:</p><pre><code>operation ::= `llhd.drv` $signal `,` $value `after` $time ( `if` $enable^ )? attr-dict `:`
              type($signal)
</code></pre><p>The <code>llhd.drv</code> operation drives a new value onto a signal. A time
operand also has to be passed, which specifies the frequency at which
the drive will be performed. An optional enable value can be passed as
last argument. In this case the drive will only be performed if the
value is 1. In case no enable signal is passed the drive will always be
performed. This operation does not define any new SSA operands.</p><p>Syntax:</p><pre><code>drv-op ::= `llhd.drv` ssa-signal `,` ssa-const `after` ssa-time
  (`if` ssa-enable)? `:` !llhd.sig&lt;const-type&gt;
</code></pre><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%init</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>1</span> <span class=p>:</span> <span class=k>i1</span>
<span class=nv>%en</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>0</span> <span class=p>:</span> <span class=k>i1</span>
<span class=nv>%time</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=nv>#llhd.time</span><span class=p>&lt;</span><span class=m>1</span>ns<span class=p>,</span> <span class=m>0</span>d<span class=p>,</span> <span class=m>0</span>e<span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>time
<span class=nv>%sig</span> <span class=p>=</span> llhd<span class=p>.</span>sig <span class=nv>%init</span> <span class=p>:</span> <span class=k>i1</span>
<span class=nv>%new</span> <span class=p>=</span> llhd<span class=p>.</span>not <span class=nv>%init</span> <span class=p>:</span> <span class=k>i1</span>

llhd<span class=p>.</span>drv <span class=nv>%sig</span><span class=p>,</span> <span class=nv>%new</span> after <span class=nv>%time</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span>
llhd<span class=p>.</span>drv <span class=nv>%sig</span><span class=p>,</span> <span class=nv>%new</span> after <span class=nv>%time</span> if <span class=nv>%en</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>signal</code></td><td>LLHD sig type of signless integer or LLHD array type or tuple values</td></tr><tr><td align=center><code>value</code></td><td>signless integer or LLHD array type or tuple</td></tr><tr><td align=center><code>time</code></td><td>LLHD time type</td></tr><tr><td align=center><code>enable</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=llhddyn_extract_element-circtllhddynextractelementop><code>llhd.dyn_extract_element</code> (::circt::llhd::DynExtractElementOp)&nbsp;<a class=headline-hash href=#llhddyn_extract_element-circtllhddynextractelementop>¶</a></h3><pre><code>Dynamically extract an element from an array or signal of array.
</code></pre><p>Syntax:</p><pre><code>operation ::= `llhd.dyn_extract_element` $target `,` $index attr-dict `:` functional-type(operands, results)
</code></pre><p>The <code>llhd.dyn_extract_element</code> operation allows to dynamically access an
element of the <code>$target</code> operand. The <code>$index</code> operand defines the index of
the element to extract. If <code>%target</code> is a signal, a new subsignal aliasing
the element will be returned.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%index</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>1</span> <span class=p>:</span> <span class=k>i2</span>

<span class=nv>%init</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>3</span> <span class=p>:</span> <span class=k>i8</span>
<span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>array_uniform <span class=nv>%init</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i8</span><span class=p>&gt;</span>
<span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span>dyn_extract_element <span class=nv>%0</span><span class=p>,</span> <span class=nv>%index</span> <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i8</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i2</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i8</span>

<span class=nv>%2</span> <span class=p>=</span> llhd<span class=p>.</span>sig <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i8</span><span class=p>&gt;</span>
<span class=nv>%3</span> <span class=p>=</span> llhd<span class=p>.</span>dyn_extract_element <span class=nv>%2</span><span class=p>,</span> <span class=nv>%index</span>
  <span class=p>:</span> <span class=p>(</span><span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i8</span><span class=p>&gt;</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i2</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>target</code></td><td>LLHD array type or LLHD sig type of LLHD array type values</td></tr><tr><td align=center><code>index</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=llhddyn_extract_slice-circtllhddynextractsliceop><code>llhd.dyn_extract_slice</code> (::circt::llhd::DynExtractSliceOp)&nbsp;<a class=headline-hash href=#llhddyn_extract_slice-circtllhddynextractsliceop>¶</a></h3><p>Dynamically extract a slice of consecutive elements</p><p>Syntax:</p><pre><code>operation ::= `llhd.dyn_extract_slice` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>The <code>llhd.dyn_extract_slice</code> operation allows to dynamically access a slice
of the <code>$target</code> operand, starting at the index given by the <code>$start</code>
operand. The resulting slice length is defined by the result type.
The <code>$target</code> operand kind has to match the result kind.
If <code>$target</code> is an array, only the number of elements can change, while
the element type has to remain the same.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>0x0f0</span> <span class=p>:</span> <span class=k>i12</span>
<span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>4</span> <span class=p>:</span> <span class=k>i3</span>

<span class=nv>%3</span> <span class=p>=</span> llhd<span class=p>.</span>dyn_extract_slice <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>(</span><span class=k>i12</span><span class=p>,</span> <span class=k>i3</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i4</span>    <span class=c>// %3: 0xf
</span></code></pre></div><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>target</code></td><td>signless integer or LLHD array type or LLHD sig type of signless integer or LLHD array type values</td></tr><tr><td align=center><code>start</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>signless integer or LLHD array type or LLHD sig type of signless integer or LLHD array type values</td></tr></tbody></table><h3 id=llhdentity-circtllhdentityop><code>llhd.entity</code> (::circt::llhd::EntityOp)&nbsp;<a class=headline-hash href=#llhdentity-circtllhdentityop>¶</a></h3><p>Create an entity.</p><p>The <code>llhd.entity</code> operation defines a new entity unit. An entity
represents the data-flow description of how a circuit&rsquo;s output values
change in reaction to changing input values.
An entity contains one region with a single block and an implicit
<code>TerminatorOp</code> terminator. Both the block name and terminator are
omitted in the custom syntax. No further blocks and control-flow are
legal inside an entity.</p><p>Syntax:</p><pre><code>entity-op ::= `llhd.entity` entity-symbol `(` arg-list `)` `-&gt;`
  `(` out-list `)` attr-dict entity-region
</code></pre><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>llhd<span class=p>.</span>entity <span class=nf>@Foo</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span> <span class=p>{</span>
  <span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>0</span> <span class=p>:</span> <span class=k>i1</span>
  <span class=nv>%toggle</span> <span class=p>=</span> llhd<span class=p>.</span>sig <span class=nv>%0</span> <span class=p>:</span> <span class=k>i1</span> <span class=p>-&gt;</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span>
  <span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span>prb <span class=nv>%toggle</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>i1</span>
  <span class=nv>%2</span> <span class=p>=</span> llhd<span class=p>.</span>not <span class=nv>%1</span> <span class=p>:</span> <span class=k>i1</span>
  <span class=nv>%dt</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=nv>#llhd.time</span><span class=p>&lt;</span><span class=m>1</span>ns<span class=p>,</span> <span class=m>0</span>d<span class=p>,</span> <span class=m>0</span>e<span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>time
  llhd<span class=p>.</span>drv <span class=nv>%toggle</span><span class=p>,</span> <span class=nv>%2</span><span class=p>,</span> <span class=nv>%dt</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=p>!</span>llhd<span class=p>.</span>time
<span class=p>}</span>
</code></pre></div><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>ins</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h3 id=llhdeq-circtllhdeqop><code>llhd.eq</code> (::circt::llhd::EqOp)&nbsp;<a class=headline-hash href=#llhdeq-circtllhdeqop>¶</a></h3><p>Logical Equality</p><p>Syntax:</p><pre><code>operation ::= `llhd.eq` operands attr-dict `:` type($lhs)
</code></pre><p>This operation compares two values and returns 1 if they are the same and 0
otherwise. It is capable of comparing all types in the LLHD dialect. It
performs element-wise equality for arrays and tuples.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%const1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%const2</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%eq</span> <span class=p>=</span> llhd<span class=p>.</span>eq <span class=nv>%const1</span><span class=p>,</span> <span class=nv>%const2</span> <span class=p>:</span> <span class=k>i32</span>  <span class=c>// %eq = 0
</span><span class=c></span>
<span class=nv>%const3</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i1</span>
<span class=nv>%tup1</span> <span class=p>=</span> llhd<span class=p>.</span>tuple <span class=nv>%const1</span><span class=p>,</span> <span class=nv>%const3</span> <span class=p>:</span> tuple<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> <span class=k>i1</span><span class=p>&gt;</span>
<span class=nv>%tup2</span> <span class=p>=</span> llhd<span class=p>.</span>tuple <span class=nv>%const2</span><span class=p>,</span> <span class=nv>%const3</span> <span class=p>:</span> tuple<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> <span class=k>i1</span><span class=p>&gt;</span>
<span class=nv>%tupeq</span> <span class=p>=</span> llhd<span class=p>.</span>eq <span class=nv>%tup1</span><span class=p>,</span> <span class=nv>%tup2</span> <span class=p>:</span> <span class=k>i32</span>  <span class=c>// %tupeq = 0
</span></code></pre></div><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>any type</td></tr><tr><td align=center><code>rhs</code></td><td>any type</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=llhdextract_element-circtllhdextractelementop><code>llhd.extract_element</code> (::circt::llhd::ExtractElementOp)&nbsp;<a class=headline-hash href=#llhdextract_element-circtllhdextractelementop>¶</a></h3><pre><code>Extract an element from an array, tuple, or signal of an array or tuple.
</code></pre><p>Syntax:</p><pre><code>operation ::= `llhd.extract_element` $target `,` $index attr-dict `:` type($target) `-&gt;` type($result)
</code></pre><p>The <code>llhd.extract_element</code> operation allows access to an element of the
<code>$target</code> operand. The <code>$index</code> attribute defines the index of the element
to extract. If <code>%target</code> is a signal, a new subsignal aliasing the element
will be returned.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%init</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>3</span> <span class=p>:</span> <span class=k>i8</span>
<span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>array_uniform <span class=nv>%init</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i8</span><span class=p>&gt;</span>
<span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span>extract_element <span class=nv>%0</span><span class=p>,</span> <span class=m>0</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i8</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>i8</span>

<span class=nv>%2</span> <span class=p>=</span> llhd<span class=p>.</span>sig <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i8</span><span class=p>&gt;</span>
<span class=nv>%3</span> <span class=p>=</span> llhd<span class=p>.</span>extract_element <span class=nv>%2</span><span class=p>,</span> <span class=m>0</span>
  <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i8</span><span class=p>&gt;</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>

<span class=nv>%4</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>8</span> <span class=p>:</span> <span class=k>i16</span>
<span class=nv>%5</span> <span class=p>=</span> llhd<span class=p>.</span>tuple <span class=nv>%0</span><span class=p>,</span> <span class=nv>%4</span> <span class=p>:</span> tuple<span class=p>&lt;</span><span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i8</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i16</span><span class=p>&gt;</span>
<span class=nv>%6</span> <span class=p>=</span> llhd<span class=p>.</span>extract_element <span class=nv>%5</span><span class=p>,</span> <span class=m>1</span> <span class=p>:</span> tuple<span class=p>&lt;</span><span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i8</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i16</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>i16</span>
</code></pre></div><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>index</code></td><td align=center>::mlir::IntegerAttr</td><td>index attribute</td></tr></tbody></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>target</code></td><td>LLHD array type or tuple or LLHD sig type of LLHD array type or tuple values</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=llhdextract_slice-circtllhdextractsliceop><code>llhd.extract_slice</code> (::circt::llhd::ExtractSliceOp)&nbsp;<a class=headline-hash href=#llhdextract_slice-circtllhdextractsliceop>¶</a></h3><p>Extract a slice of consecutive elements.</p><p>Syntax:</p><pre><code>operation ::= `llhd.extract_slice` $target `,` $start attr-dict `:` type($target) `-&gt;` type($result)
</code></pre><p>The <code>llhd.extract_slice</code> operation allows access to a slice of the <code>$target</code>
operand. The <code>$start</code> attribute defines the index of the first element.
The return type is the same as <code>$target</code> but with the width of the
specified result type.
If <code>%target</code> is a signal, a new subsignal aliasing the slice will be
returned.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>123</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span>extract_slice <span class=nv>%0</span><span class=p>,</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i2</span>

<span class=nv>%2</span> <span class=p>=</span> llhd<span class=p>.</span>sig <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%3</span> <span class=p>=</span> llhd<span class=p>.</span>extract_slice <span class=nv>%2</span><span class=p>,</span> <span class=m>0</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i5</span><span class=p>&gt;</span>
</code></pre></div><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>start</code></td><td align=center>::mlir::IntegerAttr</td><td>index attribute</td></tr></tbody></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>target</code></td><td>signless integer or LLHD array type or LLHD sig type of signless integer or LLHD array type values</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>signless integer or LLHD array type or LLHD sig type of signless integer or LLHD array type values</td></tr></tbody></table><h3 id=llhdhalt-circtllhdhaltop><code>llhd.halt</code> (::circt::llhd::HaltOp)&nbsp;<a class=headline-hash href=#llhdhalt-circtllhdhaltop>¶</a></h3><p>Terminates execution of a process.</p><p>Syntax:</p><pre><code>operation ::= `llhd.halt` attr-dict
</code></pre><p>The <code>halt</code> instruction terminates execution of a process. All processes
must halt eventually or consist of an infinite loop.</p><ul><li>This is a terminator instruction</li><li>This instruction is only allowed in processes (<code>llhd.proc</code>).</li></ul><p>Syntax:</p><pre><code>halt-op ::= `llhd.halt`
</code></pre><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>llhd<span class=p>.</span>halt
</code></pre></div><h3 id=llhdinsert_element-circtllhdinsertelementop><code>llhd.insert_element</code> (::circt::llhd::InsertElementOp)&nbsp;<a class=headline-hash href=#llhdinsert_element-circtllhdinsertelementop>¶</a></h3><p>Insert an element into an array or tuple.</p><p>Syntax:</p><pre><code>operation ::= `llhd.insert_element` $target `,` $element `,` $index attr-dict `:`
              type($target) `,` type($element)
</code></pre><p>The <code>llhd.insert_element</code> operation allows insertion of an element
represented by the <code>$element</code> operand into the <code>$target</code> operand. The
<code>$index</code> attribute defines the index where to insert the element. The return
type is the same as <code>$target</code>. Note that the <code>$target</code> is not changed, but a
new value with the element inserted is returned.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%init</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>1</span> <span class=p>:</span> <span class=k>i8</span>
<span class=nv>%target</span> <span class=p>=</span> llhd<span class=p>.</span>array_uniform <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i8</span><span class=p>&gt;</span>
<span class=nv>%element</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>2</span> <span class=p>:</span> <span class=k>i8</span>
<span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>insert_element <span class=nv>%target</span><span class=p>,</span> <span class=nv>%element</span><span class=p>,</span> <span class=m>0</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i8</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i8</span>

<span class=nv>%tuptarget</span> <span class=p>=</span> llhd<span class=p>.</span>tuple <span class=nv>%element</span><span class=p>,</span> <span class=nv>%target</span> <span class=p>:</span> tuple<span class=p>&lt;</span><span class=k>i8</span><span class=p>,</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i8</span><span class=p>&gt;</span>
<span class=nv>%newelement</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>4</span> <span class=p>:</span> <span class=k>i8</span>
<span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span>insert_element <span class=nv>%tuptarget</span><span class=p>,</span> <span class=nv>%newelement</span><span class=p>,</span> <span class=m>0</span>
  <span class=p>:</span> tuple<span class=p>&lt;</span><span class=k>i8</span><span class=p>,</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i8</span><span class=p>&gt;</span><span class=p>&gt;</span><span class=p>,</span> <span class=k>i8</span>
</code></pre></div><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>index</code></td><td align=center>::mlir::IntegerAttr</td><td>index attribute</td></tr></tbody></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>target</code></td><td>LLHD array type or tuple</td></tr><tr><td align=center><code>element</code></td><td>any type</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>LLHD array type or tuple</td></tr></tbody></table><h3 id=llhdinsert_slice-circtllhdinsertsliceop><code>llhd.insert_slice</code> (::circt::llhd::InsertSliceOp)&nbsp;<a class=headline-hash href=#llhdinsert_slice-circtllhdinsertsliceop>¶</a></h3><p>Insert a slice of consecutive elements.</p><p>Syntax:</p><pre><code>operation ::= `llhd.insert_slice` $target `,` $slice `,` $start attr-dict `:` type($target) `,` type($slice)
</code></pre><p>The <code>llhd.insert_slice</code> operation allows insertion of a slice represented by
the <code>$slice</code> operand into the <code>$target</code> operand. The <code>$start</code> attribute
defines the index of the first element. The return type is the same as
<code>$target</code>. Note that the <code>$target</code> is not changed, but a new value with
the slice inserted is returned.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%itarget</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>123</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%islice</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>2</span> <span class=p>:</span> <span class=k>i2</span>
<span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>insert_slice <span class=nv>%itarget</span><span class=p>,</span> <span class=nv>%islice</span><span class=p>,</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i2</span>

<span class=nv>%init1</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>2</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%init2</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>3</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%vtarget</span> <span class=p>=</span> llhd<span class=p>.</span>array_uniform <span class=nv>%init1</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span>
<span class=nv>%vslice</span> <span class=p>=</span> llhd<span class=p>.</span>array_uniform <span class=nv>%init2</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;</span>
<span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span>insert_slice <span class=nv>%vtarget</span><span class=p>,</span> <span class=nv>%vslice</span><span class=p>,</span> <span class=m>0</span>
  <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;</span>
</code></pre></div><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>start</code></td><td align=center>::mlir::IntegerAttr</td><td>index attribute</td></tr></tbody></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>target</code></td><td>signless integer or LLHD array type</td></tr><tr><td align=center><code>slice</code></td><td>signless integer or LLHD array type</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>signless integer or LLHD array type</td></tr></tbody></table><h3 id=llhdinst-circtllhdinstop><code>llhd.inst</code> (::circt::llhd::InstOp)&nbsp;<a class=headline-hash href=#llhdinst-circtllhdinstop>¶</a></h3><p>Instantiates a process or entity.</p><p>Syntax:</p><pre><code>operation ::= `llhd.inst` $name $callee `(` $inputs `)` `-&gt;` `(` $outputs `)` attr-dict `:`
              functional-type($inputs, $outputs)
</code></pre><p>Instantiates a process or entity and thus allows to build hierarchies.
Can only be used within an entity. An instance defines a unique name
within the entity it resides in.</p><p>Syntax:</p><pre><code>inst-op ::= `llhd.inst` inst-name symbol-name `(` ssa-input-list `)` `-&gt;`
  `(` ssa-output-list `)` attr-dict `:`
  functional-type(ssa-input-list, ssa-output-list)
</code></pre><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>llhd<span class=p>.</span>inst <span class=s>&#34;foo&#34;</span> <span class=nf>@empty</span><span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>)</span>
llhd<span class=p>.</span>inst <span class=s>&#34;bar&#34;</span> <span class=nf>@proc_symbol</span><span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=nv>%out0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
llhd<span class=p>.</span>inst <span class=s>&#34;baz&#34;</span> <span class=nf>@entity_symbol</span><span class=p>(</span><span class=nv>%in0</span><span class=p>,</span> <span class=nv>%in1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=nv>%out0</span><span class=p>,</span> <span class=nv>%out1</span><span class=p>)</span> <span class=p>:</span>
  <span class=p>(</span><span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i16</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i4</span><span class=p>&gt;</span><span class=p>)</span>
</code></pre></div><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td align=center><code>callee</code></td><td align=center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>inputs</code></td><td>LLHD sig type of signless integer or LLHD array type or tuple values</td></tr><tr><td align=center><code>outputs</code></td><td>LLHD sig type of signless integer or LLHD array type or tuple values</td></tr></tbody></table><h3 id=llhdload-circtllhdloadop><code>llhd.load</code> (::circt::llhd::LoadOp)&nbsp;<a class=headline-hash href=#llhdload-circtllhdloadop>¶</a></h3><p>Load a value.</p><p>Syntax:</p><pre><code>operation ::= `llhd.load` $pointer attr-dict `:` type($pointer)
</code></pre><p>The <code>llhd.load</code> operation loads a value from a memory region given by
<code>pointer</code>.</p><p><strong>Examples:</strong></p><pre><code>%int = llhd.const 0 : i32
%arr = llhd.array_uniform %int : !llhd.array&lt;3xi32&gt;
%iPtr = llhd.var %int : i32
%arrPtr = llhd.var %arr : !llhd.array&lt;3xi32&gt;

%iLd = llhd.load %iPtr : !llhd.ptr&lt;i32&gt;
%arrLd = llhd.load %arrPtr : !llhd.ptr&lt;!llhd.array&lt;3xi32&gt;&gt;
</code></pre><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pointer</code></td><td>LLHD pointer type of signless integer or LLHD array type or tuple values</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>signless integer or LLHD array type or tuple</td></tr></tbody></table><h3 id=llhdneg-circtllhdnegop><code>llhd.neg</code> (::circt::llhd::NegOp)&nbsp;<a class=headline-hash href=#llhdneg-circtllhdnegop>¶</a></h3><p>Negate a value.</p><p>The operand and result always have the same type. The type has to be a
signless integer of any width. Although, only signless integers are
allowed, this instruction applies two&rsquo;s complement negation of the
integer, basically treating it as a signed integer.</p><p>Syntax:</p><pre><code>neg-op ::= ssa-id `=` `llhd.neg` ssa-value attr-dict `:` type
</code></pre><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span>neg <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</code></pre></div><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>signless integer</td></tr></tbody></table><h3 id=llhdneq-circtllhdneqop><code>llhd.neq</code> (::circt::llhd::NeqOp)&nbsp;<a class=headline-hash href=#llhdneq-circtllhdneqop>¶</a></h3><p>Logical Inequality</p><p>Syntax:</p><pre><code>operation ::= `llhd.neq` operands attr-dict `:` type($lhs)
</code></pre><p>This operation compares two values and returns 1 if they are not the same
and 0 if they are the same. It is capable of comparing all types in the LLHD
dialect. It performs element-wise equality for arrays and tuples.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%const1</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%const2</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%neq</span> <span class=p>=</span> llhd<span class=p>.</span>neq <span class=nv>%const1</span><span class=p>,</span> <span class=nv>%const2</span> <span class=p>:</span> <span class=k>i32</span>  <span class=c>// %neq = 1
</span><span class=c></span>
<span class=nv>%const3</span> <span class=p>=</span> <span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i1</span>
<span class=nv>%tup1</span> <span class=p>=</span> llhd<span class=p>.</span>tuple <span class=nv>%const1</span><span class=p>,</span> <span class=nv>%const3</span> <span class=p>:</span> tuple<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> <span class=k>i1</span><span class=p>&gt;</span>
<span class=nv>%tup2</span> <span class=p>=</span> llhd<span class=p>.</span>tuple <span class=nv>%const2</span><span class=p>,</span> <span class=nv>%const3</span> <span class=p>:</span> tuple<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> <span class=k>i1</span><span class=p>&gt;</span>
<span class=nv>%tupneq</span> <span class=p>=</span> llhd<span class=p>.</span>neq <span class=nv>%tup1</span><span class=p>,</span> <span class=nv>%tup2</span> <span class=p>:</span> <span class=k>i32</span>  <span class=c>// %tupeq = 1
</span></code></pre></div><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>any type</td></tr><tr><td align=center><code>rhs</code></td><td>any type</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=llhdnot-circtllhdnotop><code>llhd.not</code> (::circt::llhd::NotOp)&nbsp;<a class=headline-hash href=#llhdnot-circtllhdnotop>¶</a></h3><p>Bitwise NOT</p><p>Takes an integer of any width or a nine-valued-logic (IEEE 1164) value
of any width as input. Flips each bit of a value. The result always has
the exact same type.</p><p>Syntax:</p><pre><code>not-op ::= ssa-id `=` `llhd.not` ssa-value attr-dict `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span>not <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</code></pre></div><p>Truth Table for integers:</p><table><thead><tr><th align=center><code>not</code></th><th align=center>0</th><th align=center>1</th></tr></thead><tbody><tr><td align=center></td><td align=center>1</td><td align=center>0</td></tr></tbody></table><p>Truth Table for nine-valued logic:</p><table><thead><tr><th align=center><code>not</code></th><th align=center>U</th><th align=center>X</th><th align=center>0</th><th align=center>1</th><th align=center>Z</th><th align=center>W</th><th align=center>L</th><th align=center>H</th><th align=center>-</th></tr></thead><tbody><tr><td align=center></td><td align=center>U</td><td align=center>X</td><td align=center>1</td><td align=center>0</td><td align=center>X</td><td align=center>X</td><td align=center>1</td><td align=center>0</td><td align=center>X</td></tr></tbody></table><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>value</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>signless integer</td></tr></tbody></table><h3 id=llhdor-circtllhdorop><code>llhd.or</code> (::circt::llhd::OrOp)&nbsp;<a class=headline-hash href=#llhdor-circtllhdorop>¶</a></h3><p>Bitwise OR</p><p>Takes two integers of the same width or two nine-valued-logic (IEEE 1164)
values of the same width as input. Calculates the bitwise OR. The
result is always of the exact same type as the two inputs.</p><p>Syntax:</p><pre><code>or-op ::= ssa-id `=` `llhd.or` ssa-lhs `,` ssa-rhs attr-dict `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span>or <span class=nv>%0</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</code></pre></div><p>Truth Table for integers:</p><table><thead><tr><th align=center><code>or</code></th><th align=center>0</th><th align=center>1</th></tr></thead><tbody><tr><td align=center>0</td><td align=center>0</td><td align=center>1</td></tr><tr><td align=center>1</td><td align=center>1</td><td align=center>1</td></tr></tbody></table><p>Truth Table for nine-valued logic:</p><table><thead><tr><th align=center><code>or</code></th><th align=center>U</th><th align=center>X</th><th align=center>0</th><th align=center>1</th><th align=center>Z</th><th align=center>W</th><th align=center>L</th><th align=center>H</th><th align=center>-</th></tr></thead><tbody><tr><td align=center>U</td><td align=center>U</td><td align=center>U</td><td align=center>U</td><td align=center>1</td><td align=center>U</td><td align=center>U</td><td align=center>U</td><td align=center>1</td><td align=center>U</td></tr><tr><td align=center>X</td><td align=center>U</td><td align=center>X</td><td align=center>X</td><td align=center>1</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>1</td><td align=center>X</td></tr><tr><td align=center>0</td><td align=center>U</td><td align=center>X</td><td align=center>0</td><td align=center>1</td><td align=center>X</td><td align=center>X</td><td align=center>0</td><td align=center>1</td><td align=center>X</td></tr><tr><td align=center>1</td><td align=center>1</td><td align=center>1</td><td align=center>1</td><td align=center>1</td><td align=center>1</td><td align=center>1</td><td align=center>1</td><td align=center>1</td><td align=center>1</td></tr><tr><td align=center>Z</td><td align=center>U</td><td align=center>X</td><td align=center>X</td><td align=center>1</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>1</td><td align=center>X</td></tr><tr><td align=center>W</td><td align=center>U</td><td align=center>X</td><td align=center>X</td><td align=center>1</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>1</td><td align=center>X</td></tr><tr><td align=center>L</td><td align=center>U</td><td align=center>X</td><td align=center>0</td><td align=center>1</td><td align=center>X</td><td align=center>X</td><td align=center>0</td><td align=center>1</td><td align=center>X</td></tr><tr><td align=center>H</td><td align=center>1</td><td align=center>1</td><td align=center>1</td><td align=center>1</td><td align=center>1</td><td align=center>1</td><td align=center>1</td><td align=center>1</td><td align=center>1</td></tr><tr><td align=center>-</td><td align=center>U</td><td align=center>X</td><td align=center>X</td><td align=center>1</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>1</td><td align=center>X</td></tr></tbody></table><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless integer</td></tr><tr><td align=center><code>rhs</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>signless integer</td></tr></tbody></table><h3 id=llhdprb-circtllhdprbop><code>llhd.prb</code> (::circt::llhd::PrbOp)&nbsp;<a class=headline-hash href=#llhdprb-circtllhdprbop>¶</a></h3><p>Probe a signal.</p><p>Syntax:</p><pre><code>operation ::= `llhd.prb` $signal attr-dict `:` type($signal)
</code></pre><p>The <code>llhd.prb</code> instruction probes a signal and returns the value it
currently carries as a new SSA operand. The result type is always
the type carried by the signal.</p><p>Syntax:</p><pre><code>prb-op ::= ssa-id `=` `llhd.prb` ssa-sig attr-dict `:` !llhd.sig&lt;type&gt;
</code></pre><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%const_i1</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>1</span> <span class=p>:</span> <span class=k>i1</span>
<span class=nv>%sig_i1</span> <span class=p>=</span> llhd<span class=p>.</span>sig <span class=nv>%const_i1</span> <span class=p>:</span> <span class=k>i1</span>
<span class=nv>%prbd</span> <span class=p>=</span> llhd<span class=p>.</span>prb <span class=nv>%sig_i1</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>signal</code></td><td>LLHD sig type of signless integer or LLHD array type or tuple values</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>signless integer or LLHD array type or tuple</td></tr></tbody></table><h3 id=llhdproc-circtllhdprocop><code>llhd.proc</code> (::circt::llhd::ProcOp)&nbsp;<a class=headline-hash href=#llhdproc-circtllhdprocop>¶</a></h3><p>Create a process</p><p>A <code>llhd.proc</code> represents control-flow in a timed fashion. It allows a
procedural description of how a circuit&rsquo;s output signals change in
reaction to changing input signals. It has a region with arbitrarily
many basic blocks. The first block is the entry block and cannot be
targeted by the terminators. It uses <code>llhd.wait</code> as a terminator to add
timed control-flow. Immediate control-flow with <code>br</code> or <code>cond_br</code> is
also possible. Every process must either contain an infinite loop or
terminate with the <code>llhd.halt</code> terminator.</p><p>How does a process compare to functions and entities?</p><table><thead><tr><th>Unit</th><th>Paradigm</th><th>Timing</th><th>Models</th></tr></thead><tbody><tr><td>Function</td><td>control-flow</td><td>immediate</td><td>Computation in zero time</td></tr><tr><td>Process</td><td>control-flow</td><td>timed</td><td>Behavioral circuit description</td></tr><tr><td>Entity</td><td>data-flow</td><td>timed</td><td>Structural circuit description</td></tr></tbody></table><p>Syntax:</p><pre><code>proc-op ::= `llhd.proc` proc-symbol `(` ssa-input-list `)` `-&gt;`
  `(` ssa-output-list `)` attr-dict `{` proc-region `}`
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>llhd<span class=p>.</span>proc <span class=nf>@example</span><span class=p>(</span><span class=nv>%in0</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span><span class=p>,</span> <span class=nv>%in1</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>-&gt;</span>
    <span class=p>(</span><span class=nv>%out2</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>{</span>
  br <span class=nl>^bb1
</span><span class=nl></span><span class=nl>^bb1</span><span class=p>:</span>
  llhd<span class=p>.</span>halt
<span class=p>}</span>
</code></pre></div><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>ins</code></td><td align=center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h3 id=llhdreg-circtllhdregop><code>llhd.reg</code> (::circt::llhd::RegOp)&nbsp;<a class=headline-hash href=#llhdreg-circtllhdregop>¶</a></h3><p>Represents a storage element</p><p>This instruction represents a storage element. It drives its output onto
the &lsquo;signal&rsquo; value. An arbitrary amount of triggers can be added to the
storage element. However, at least one is required. They are quadruples
consisting of the new value to be stored if the trigger applies, the
mode and trigger value which specify when this trigger has to be applied
as well as a delay. Optionally, each triple may also have a gate
condition, in this case the trigger only applies if the gate is one. If
multiple triggers apply the left-most in the list takes precedence.</p><p>There are five modes available:</p><table><thead><tr><th>Mode</th><th>Meaning</th></tr></thead><tbody><tr><td>&ldquo;low&rdquo;</td><td>Storage element stores <code>value</code> while the <code>trigger</code> is low. Models active-low resets and low-transparent latches.</td></tr><tr><td>&ldquo;high&rdquo;</td><td>Storage element stores <code>value</code> while the <code>trigger</code> is high. Models active-high resets and high-transparent latches.</td></tr><tr><td>&ldquo;rise&rdquo;</td><td>Storage element stores <code>value</code> upon the rising edge of the <code>trigger</code>. Models rising-edge flip-flops.</td></tr><tr><td>&ldquo;fall&rdquo;</td><td>Storage element stores <code>value</code> upon the falling edge of the <code>trigger</code>. Models falling-edge flip-flops.</td></tr><tr><td>&ldquo;both&rdquo;</td><td>Storage element stores <code>value</code> upon the a rising or a falling edge of the <code>trigger</code>. Models dual-edge flip-flops.</td></tr></tbody></table><p>This instruction may only be used in an LLHD entity.</p><p>Syntax:</p><pre><code>reg-op ::= `llhd.reg` signal-ssa-value
  ( `,` `(` value-ssa-value `,` mode-string trigger-ssa-value `after`
  delay-ssa-value ( `if` gate-ssa-value )? `:` value-type )+
  attr-dict `:` signal-type
</code></pre><p>Examples:</p><p>A rising, falling, and dual-edge triggered flip-flop:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>llhd<span class=p>.</span>reg <span class=nv>%Q</span><span class=p>,</span> <span class=p>(</span><span class=nv>%D</span><span class=p>,</span> <span class=s>&#34;rise&#34;</span> <span class=nv>%CLK</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>
llhd<span class=p>.</span>reg <span class=nv>%Q</span><span class=p>,</span> <span class=p>(</span><span class=nv>%D</span><span class=p>,</span> <span class=s>&#34;fall&#34;</span> <span class=nv>%CLK</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>
llhd<span class=p>.</span>reg <span class=nv>%Q</span><span class=p>,</span> <span class=p>(</span><span class=nv>%D</span><span class=p>,</span> <span class=s>&#34;both&#34;</span> <span class=nv>%CLK</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><p>A rising-edge triggered flip-flop with active-low reset:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>llhd<span class=p>.</span>reg <span class=nv>%Q</span><span class=p>,</span> <span class=p>(</span><span class=nv>%init</span><span class=p>,</span> <span class=s>&#34;low&#34;</span> <span class=nv>%RSTB</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span><span class=p>)</span><span class=p>,</span>
  <span class=p>(</span><span class=nv>%D</span><span class=p>,</span> <span class=s>&#34;rise&#34;</span> <span class=nv>%CLK</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><p>A rising-edge triggered enable flip-flop with active-low reset:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>llhd<span class=p>.</span>reg <span class=nv>%Q</span><span class=p>,</span> <span class=p>(</span><span class=nv>%init</span><span class=p>,</span> <span class=s>&#34;low&#34;</span> <span class=nv>%RSTB</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span><span class=p>)</span><span class=p>,</span>
  <span class=p>(</span><span class=nv>%D</span><span class=p>,</span> <span class=s>&#34;rise&#34;</span> <span class=nv>%CLK</span> after <span class=nv>%T</span> if <span class=nv>%EN</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><p>A transparent-low and transparent-high latch:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>llhd<span class=p>.</span>reg <span class=nv>%Q</span><span class=p>,</span> <span class=p>(</span><span class=nv>%D</span><span class=p>,</span> <span class=s>&#34;low&#34;</span> <span class=nv>%CLK</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>
llhd<span class=p>.</span>reg <span class=nv>%Q</span><span class=p>,</span> <span class=p>(</span><span class=nv>%D</span><span class=p>,</span> <span class=s>&#34;high&#34;</span> <span class=nv>%CLK</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>
</code></pre></div><p>An SR latch:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>0</span> <span class=p>:</span> <span class=k>i1</span>
<span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>1</span> <span class=p>:</span> <span class=k>i1</span>
llhd<span class=p>.</span>reg <span class=nv>%Q</span><span class=p>,</span> <span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=s>&#34;high&#34;</span> <span class=nv>%R</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span><span class=p>,</span>
  <span class=p>(</span><span class=nv>%1</span><span class=p>,</span> <span class=s>&#34;high&#34;</span> <span class=nv>%S</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span>
</code></pre></div><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>modes</code></td><td align=center>::mlir::ArrayAttr</td><td>reg mode array attribute</td></tr><tr><td align=center><code>gateMask</code></td><td align=center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr></tbody></table><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>signal</code></td><td>LLHD sig type of signless integer or LLHD array type or tuple values</td></tr><tr><td align=center><code>values</code></td><td>signless integer or LLHD array type or tuple or LLHD sig type of signless integer or LLHD array type or tuple values</td></tr><tr><td align=center><code>triggers</code></td><td>1-bit signless integer</td></tr><tr><td align=center><code>delays</code></td><td>LLHD time type</td></tr><tr><td align=center><code>gates</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=llhdsmod-circtllhdsmodop><code>llhd.smod</code> (::circt::llhd::SModOp)&nbsp;<a class=headline-hash href=#llhdsmod-circtllhdsmodop>¶</a></h3><p>Signed modulo.</p><p>This instruction computes the signed modulo of two signless integers of
any width, treating the leading bit as sign. The operand and result
types always have to be the same.
To calculate the signed remainder of two integers, use <code>remi_signed</code>
from the standard dialect.</p><p>Syntax:</p><pre><code>smod-op ::= ssa-id `=` `llhd.smod` ssa-lhs `,` ssa-rhs attr-dict `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>9</span> <span class=p>:</span> <span class=k>i4</span>
<span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>4</span> <span class=p>:</span> <span class=k>i4</span>
<span class=nv>%2</span> <span class=p>=</span> llhd<span class=p>.</span>smod <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i4</span>
</code></pre></div><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless integer</td></tr><tr><td align=center><code>rhs</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>signless integer</td></tr></tbody></table><h3 id=llhdshl-circtllhdshlop><code>llhd.shl</code> (::circt::llhd::ShlOp)&nbsp;<a class=headline-hash href=#llhdshl-circtllhdshlop>¶</a></h3><p>Shifts a value to the left by a given amount.</p><p>Syntax:</p><pre><code>operation ::= `llhd.shl` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>The type of the base value and the hidden value must be the same, but
may differ in the number of bits or elements. The result always has the
same type (including width) of the base value.
The instruction is transparent to signals and pointers. For example,
passing a signal as argument will shift the underlying value and return
a signal to the shifted value.
Allowed (underlying) types are signless integers, nine-valued-logic values
and arrays. The shift amount has to be a signless integer. A shift amount
bigger than the number of bits or elements of the hidden value is undefined.
The hidden value is uncovered by non-zero shift amounts. E.g. consider
the four bit values <code>base = 0xf</code>, <code>hidden = 0xc</code> shifted by an amount of
three result in <code>0xe</code>.</p><p>Syntax:</p><pre><code>shl-op ::= ssa-id `=`
  `llhd.shl` ssa-base `,` ssa-hidden `,` ssa-amount attr-dict `:`
  `(` base-type `,` hidden-type `,` amount-type `)` `-&gt;` result-type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>shl <span class=nv>%base</span><span class=p>,</span> <span class=nv>%hidden</span><span class=p>,</span> <span class=nv>%amount</span> <span class=p>:</span> <span class=p>(</span><span class=k>i4</span><span class=p>,</span> <span class=k>i2</span><span class=p>,</span> <span class=k>i2</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i4</span>
</code></pre></div><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>base</code></td><td>signless integer or LLHD array type or LLHD sig type of signless integer or LLHD array type values</td></tr><tr><td align=center><code>hidden</code></td><td>signless integer or LLHD array type or LLHD sig type of signless integer or LLHD array type values</td></tr><tr><td align=center><code>amount</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>signless integer or LLHD array type or LLHD sig type of signless integer or LLHD array type values</td></tr></tbody></table><h3 id=llhdshr-circtllhdshrop><code>llhd.shr</code> (::circt::llhd::ShrOp)&nbsp;<a class=headline-hash href=#llhdshr-circtllhdshrop>¶</a></h3><p>Shifts a value to the right by a given amount.</p><p>Syntax:</p><pre><code>operation ::= `llhd.shr` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>The type of the base value and the hidden value must be the same, but
may differ in the number of bits or elements. The result always has the
same type (including width) of the base value.
The instruction is transparent to signals and pointers. For example,
passing a signal as argument will shift the underlying value and return
a signal to the shifted value.
Allowed (underlying) types are signless integers, nine-valued-logic values
and arrays. The shift amount has to be a signless integer. A shift amount
bigger than the number of bits or elements of the hidden value is undefined.
The hidden value is uncovered by non-zero shift amounts. E.g. consider
the four bit values <code>base = 0xf</code>, <code>hidden = 0xc</code> shifted by an amount of
three result in <code>0x9</code>.</p><p>Syntax:</p><pre><code>shr-op ::= ssa-id `=`
  `llhd.shr` ssa-base `,` ssa-hidden `,` ssa-amount attr-dict `:`
  `(` base-type `,` hidden-type `,` amount-type `)` `-&gt;` result-type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>shr <span class=nv>%base</span><span class=p>,</span> <span class=nv>%hidden</span><span class=p>,</span> <span class=nv>%amount</span> <span class=p>:</span> <span class=p>(</span><span class=k>i4</span><span class=p>,</span> <span class=k>i2</span><span class=p>,</span> <span class=k>i2</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i4</span>
</code></pre></div><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>base</code></td><td>signless integer or LLHD array type or LLHD sig type of signless integer or LLHD array type values</td></tr><tr><td align=center><code>hidden</code></td><td>signless integer or LLHD array type or LLHD sig type of signless integer or LLHD array type values</td></tr><tr><td align=center><code>amount</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>signless integer or LLHD array type or LLHD sig type of signless integer or LLHD array type values</td></tr></tbody></table><h3 id=llhdsig-circtllhdsigop><code>llhd.sig</code> (::circt::llhd::SigOp)&nbsp;<a class=headline-hash href=#llhdsig-circtllhdsigop>¶</a></h3><p>Create a signal.</p><p>Syntax:</p><pre><code>operation ::= `llhd.sig` $name $init attr-dict `:` type($init)
</code></pre><p>The <code>llhd.sig</code> instruction introduces a new signal in the IR. The input
operand determines the initial value carried by the signal, while the
result type will always be a signal carrying the type of the init operand.
A signal defines a unique name within the entity it resides in. Signals
can only be allocated within entities.</p><p>Syntax:</p><pre><code>sig-op ::= ssa-id `=` `llhd.sig` sig-name ssa-init attr-dict `:` init-type
</code></pre><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%init_i64</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>123</span> <span class=p>:</span> <span class=k>i64</span>
<span class=nv>%sig_i64</span> <span class=p>=</span> llhd<span class=p>.</span>sig <span class=s>&#34;foo&#34;</span> <span class=nv>%init_64</span> <span class=p>:</span> <span class=k>i64</span>

<span class=nv>%init_i1</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>1</span> <span class=p>:</span> <span class=k>i1</span>
<span class=nv>%sig_i1</span> <span class=p>=</span> llhd<span class=p>.</span>sig <span class=s>&#34;bar&#34;</span> <span class=nv>%init_i1</span> <span class=p>:</span> <span class=k>i1</span>
</code></pre></div><p>The first <code>llhd.sig</code> instruction creates a new signal named &ldquo;foo&rdquo;, carrying
an <code>i64</code> type with initial value of 123, while the second one creates a new
signal named &ldquo;bar&rdquo;, carrying an <code>i1</code> type with initial value of 1.</p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>name</code></td><td align=center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>init</code></td><td>signless integer or LLHD array type or tuple</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>LLHD sig type of signless integer or LLHD array type or tuple values</td></tr></tbody></table><h3 id=llhdstore-circtllhdstoreop><code>llhd.store</code> (::circt::llhd::StoreOp)&nbsp;<a class=headline-hash href=#llhdstore-circtllhdstoreop>¶</a></h3><p>Store a value.</p><p>Syntax:</p><pre><code>operation ::= `llhd.store` $pointer `,` $value attr-dict `:` type($pointer)
</code></pre><p>The <code>llhd.store</code> operation stores the value <code>value</code> to the memory region
given by <code>pointer</code>.</p><p><strong>Examples:</strong></p><pre><code>%int = llhd.const 0 : i32
%arr = llhd.array_uniform %int : !llhd.array&lt;3xi32&gt;
%iPtr = llhd.var %int : i32
%arrPtr = llhd.var %arr : !llhd.array&lt;3xi32&gt;

llhd.store %iPtr, %int : !llhd.ptr&lt;i32&gt;
llhd.store %arrPtr, %arr : !llhd.ptr&lt;!llhd.array&lt;3xi32&gt;&gt;
</code></pre><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>pointer</code></td><td>LLHD pointer type of signless integer or LLHD array type or tuple values</td></tr><tr><td align=center><code>value</code></td><td>signless integer or LLHD array type or tuple</td></tr></tbody></table><h3 id=llhdterminator-circtllhdterminatorop><code>llhd.terminator</code> (::circt::llhd::TerminatorOp)&nbsp;<a class=headline-hash href=#llhdterminator-circtllhdterminatorop>¶</a></h3><p>Dummy terminator</p><p>The <code>"llhd.terminator"</code> op is a dummy terminator for an <code>EntityOp</code> unit.
It provides no further meaning other than ensuring correct termination
of an entitiy&rsquo;s region. This operation provides no custom syntax and
should never explicitly appear in LLHD&rsquo;s custom syntax.</p><h3 id=llhdtuple-circtllhdtupleop><code>llhd.tuple</code> (::circt::llhd::TupleOp)&nbsp;<a class=headline-hash href=#llhdtuple-circtllhdtupleop>¶</a></h3><p>Create a tuple from a list of values.</p><p>Syntax:</p><pre><code>operation ::= `llhd.tuple` $values attr-dict `:` type($result)
</code></pre><p>The <code>llhd.tuple</code> operation creates a tuple from a list of SSA-values.</p><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%c1</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%c2</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>2</span> <span class=p>:</span> <span class=k>i2</span>
<span class=nv>%sig</span> <span class=p>=</span> llhd<span class=p>.</span>sig <span class=s>&#34;sig_name&#34;</span> <span class=nv>%c1</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%array</span> <span class=p>=</span> llhd<span class=p>.</span>array_uniform <span class=nv>%c1</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;</span>
<span class=nv>%tuple</span> <span class=p>=</span> llhd<span class=p>.</span>tuple <span class=nv>%c1</span><span class=p>,</span> <span class=nv>%c2</span><span class=p>,</span> <span class=nv>%array</span><span class=p>,</span> <span class=nv>%sig</span> <span class=p>:</span>
  tuple<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> <span class=k>i2</span><span class=p>,</span> <span class=p>!</span>llhd<span class=p>.</span>array<span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span><span class=p>&gt;</span>
</code></pre></div><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>values</code></td><td>any type</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>tuple</td></tr></tbody></table><h3 id=llhdvar-circtllhdvarop><code>llhd.var</code> (::circt::llhd::VarOp)&nbsp;<a class=headline-hash href=#llhdvar-circtllhdvarop>¶</a></h3><p>Stack allocation.</p><p>Syntax:</p><pre><code>operation ::= `llhd.var` $init attr-dict `:` type($init)
</code></pre><p>The <code>llhd.var</code> operation allocates a memory region on the stack with the
initial value given by <code>init</code>, and returns a pointer to the allocated
region.</p><p><strong>Examples:</strong></p><pre><code>%int = llhd.const 0 : i32
%arr = llhd.array_uniform %int : !llhd.array&lt;3xi32&gt;

%iPtr = llhd.var %int : i32
%arrPtr = llhd.var %arr : !llhd.array&lt;3xi32&gt;
</code></pre><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>init</code></td><td>signless integer or LLHD array type or tuple</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>result</code></td><td>LLHD pointer type of signless integer or LLHD array type or tuple values</td></tr></tbody></table><h3 id=llhdwait-circtllhdwaitop><code>llhd.wait</code> (::circt::llhd::WaitOp)&nbsp;<a class=headline-hash href=#llhdwait-circtllhdwaitop>¶</a></h3><p>Suspends execution of a process.</p><p>Syntax:</p><pre><code>operation ::= `llhd.wait` (`for` $time^ `,`)? (`(`$obs^ `:` type($obs)`)` `,`)?
              $dest (`(` $destOps^ `:` type($destOps) `)`)? attr-dict
</code></pre><p>The <code>wait</code> instruction suspends execution of a process until any of the
observed signals change or a fixed time interval has passed. Execution
resumes at the specified basic block with the passed arguments.</p><ul><li>This is a terminator instruction.</li><li>This instruction is only allowed in processes (<code>llhd.proc</code>).</li></ul><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>llhd<span class=p>.</span>wait <span class=nl>^bb1
</span><span class=nl></span>llhd<span class=p>.</span>wait for <span class=nv>%time</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%time</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>time<span class=p>)</span>
llhd<span class=p>.</span>wait <span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span>
llhd<span class=p>.</span>wait for <span class=nv>%time</span><span class=p>,</span> <span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>)</span><span class=p>,</span>
  <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span><span class=p>,</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span><span class=p>)</span>
</code></pre></div><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>obs</code></td><td>LLHD sig type of signless integer or LLHD array type or tuple values</td></tr><tr><td align=center><code>time</code></td><td>LLHD time type</td></tr><tr><td align=center><code>destOps</code></td><td>any type</td></tr></tbody></table><h4 id=successors>Successors:&nbsp;<a class=headline-hash href=#successors>¶</a></h4><table><thead><tr><th align=center>Successor</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>dest</code></td><td>any successor</td></tr></tbody></table><h3 id=llhdxor-circtllhdxorop><code>llhd.xor</code> (::circt::llhd::XorOp)&nbsp;<a class=headline-hash href=#llhdxor-circtllhdxorop>¶</a></h3><p>Bitwise XOR</p><p>Takes two integers of the same width or two nine-valued-logic (IEEE 1164)
values of the same width as input. Calculates the bitwise XOR. The
result is always of the exact same type as the two inputs.</p><p>Syntax:</p><pre><code>xor-op ::= ssa-id `=` `llhd.xor` ssa-lhs `,` ssa-rhs attr-dict `:` type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span>
<span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span>xor <span class=nv>%0</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</code></pre></div><p>Truth Table for integers:</p><table><thead><tr><th align=center><code>xor</code></th><th align=center>0</th><th align=center>1</th></tr></thead><tbody><tr><td align=center>0</td><td align=center>0</td><td align=center>1</td></tr><tr><td align=center>1</td><td align=center>1</td><td align=center>0</td></tr></tbody></table><p>Truth Table for nine-valued logic:</p><table><thead><tr><th align=center><code>xor</code></th><th align=center>U</th><th align=center>X</th><th align=center>0</th><th align=center>1</th><th align=center>Z</th><th align=center>W</th><th align=center>L</th><th align=center>H</th><th align=center>-</th></tr></thead><tbody><tr><td align=center>U</td><td align=center>U</td><td align=center>U</td><td align=center>U</td><td align=center>U</td><td align=center>U</td><td align=center>U</td><td align=center>U</td><td align=center>U</td><td align=center>U</td></tr><tr><td align=center>X</td><td align=center>U</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td></tr><tr><td align=center>0</td><td align=center>U</td><td align=center>X</td><td align=center>0</td><td align=center>1</td><td align=center>X</td><td align=center>X</td><td align=center>0</td><td align=center>1</td><td align=center>X</td></tr><tr><td align=center>1</td><td align=center>U</td><td align=center>X</td><td align=center>1</td><td align=center>0</td><td align=center>X</td><td align=center>X</td><td align=center>1</td><td align=center>0</td><td align=center>X</td></tr><tr><td align=center>Z</td><td align=center>U</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td></tr><tr><td align=center>W</td><td align=center>U</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td></tr><tr><td align=center>L</td><td align=center>U</td><td align=center>X</td><td align=center>0</td><td align=center>1</td><td align=center>X</td><td align=center>X</td><td align=center>0</td><td align=center>1</td><td align=center>X</td></tr><tr><td align=center>H</td><td align=center>U</td><td align=center>X</td><td align=center>1</td><td align=center>0</td><td align=center>X</td><td align=center>X</td><td align=center>1</td><td align=center>0</td><td align=center>X</td></tr><tr><td align=center>-</td><td align=center>U</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td><td align=center>X</td></tr></tbody></table><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th align=center>Operand</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>lhs</code></td><td>signless integer</td></tr><tr><td align=center><code>rhs</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th align=center>Result</th><th>Description</th></tr></thead><tbody><tr><td align=center>«unnamed»</td><td>signless integer</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/Handshake/ title="'handshake' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - 'handshake' Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/RTL/ title="'rtl' Dialect">Next - 'rtl' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/ESI/>'esi' Dialect</a></li><li><a href=/docs/Dialects/FIRRTL/>'firrtl' Dialect</a></li><li><a href=/docs/Dialects/Handshake/>'handshake' Dialect</a></li><li class=active><a href=/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li><a href=/docs/Dialects/RTL/>'rtl' Dialect</a></li><li><a href=/docs/Dialects/StaticLogic/>'staticlogic' Dialect</a></li><li><a href=/docs/Dialects/SV/>'sv' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/ESI/>ESI<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/ESI/cosim/>ESI cosimulation model</a></li></ul></li><li><a href=/docs/SVPasses/></a></li><li><a href=/docs/Charter/>CIRCT Charter</a></li><li><a href=/docs/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/RationaleRTL-SV/>RTL and SV Dialect Rationale</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>