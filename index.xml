<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CIRCT</title><link>https://circt.llvm.org/</link><description>Recent content on CIRCT</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 19 Oct 2017 15:26:15 +0000</lastBuildDate><atom:link href="https://circt.llvm.org/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://circt.llvm.org/docs/SVPasses/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/SVPasses/</guid><description>-sv-always-fusion: Combine AlwaysFF blocks with the same predicate This pass finds all AlwaysFF operations with the same condition, and combines them in to a single operation. For example:
// Input rtl.module() { sv.alwaysff(posedge %clock) { sv.passign %counter, %1 : i8 } sv.alwaysff(posedge %clock) { sv.passign %param, %2 : i16 } } // Output rtl.module() { sv.alwaysff(posedge %clock) { sv.passign %counter, %1 : i8 sv.passign %param, %2 : i16 } }</description></item><item><title>'esi' Dialect</title><link>https://circt.llvm.org/docs/Dialects/ESI/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/</guid><description>Type constraint definition An ESI-compatible channel port Operation definition esi.decode.capnp (::circt::esi::CapnpDecode) esi.encode.capnp (::circt::esi::CapnpEncode) esi.buffer (::circt::esi::ChannelBuffer) esi.cosim (::circt::esi::CosimEndpoint) esi.stage (::circt::esi::PipelineStage) esi.unwrap.iface (::circt::esi::UnwrapSVInterface) esi.unwrap.vr (::circt::esi::UnwrapValidReady) esi.wrap.iface (::circt::esi::WrapSVInterface) esi.wrap.vr (::circt::esi::WrapValidReady) Type definition Channel (ChannelPort) Type constraint definition An ESI-compatible channel port An ESI port kind which models a latency-insensitive, unidirectional, point-to-point data stream. Channels are typed (like all of ESI). Said type can be any MLIR type, but must be lowered to something a backend knows how to output (i.</description></item><item><title>'firrtl' Dialect</title><link>https://circt.llvm.org/docs/Dialects/FIRRTL/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/FIRRTL/</guid><description>Types and operations for firrtl dialect This dialect defines the firrtl dialect, which is used to lower from Chisel code to Verilog. For more information, see the FIRRTL GitHub page .
Operation definition firrtl.add (::circt::firrtl::AddPrimOp) firrtl.analogInOutCast (::circt::firrtl::AnalogInOutCastOp) firrtl.and (::circt::firrtl::AndPrimOp) firrtl.andr (::circt::firrtl::AndRPrimOp) firrtl.asAsyncReset (::circt::firrtl::AsAsyncResetPrimOp) firrtl.asClock (::circt::firrtl::AsClockPrimOp) firrtl.asNonPassive (::circt::firrtl::AsNonPassivePrimOp) firrtl.asPassive (::circt::firrtl::AsPassivePrimOp) firrtl.asSInt (::circt::firrtl::AsSIntPrimOp) firrtl.asUInt (::circt::firrtl::AsUIntPrimOp) firrtl.assert (::circt::firrtl::AssertOp) firrtl.assume (::circt::firrtl::AssumeOp) firrtl.attach (::circt::firrtl::AttachOp) firrtl.bits (::circt::firrtl::BitsPrimOp) firrtl.cmem (::circt::firrtl::CMemOp) firrtl.cat (::circt::firrtl::CatPrimOp) firrtl.circuit (::circt::firrtl::CircuitOp) firrtl.connect (::circt::firrtl::ConnectOp) firrtl.</description></item><item><title>'handshake' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Handshake/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Handshake/</guid><description>Principle Choice of MLIR IR Representation Conventions Resources Operation definitions handshake.branch (::circt::handshake::BranchOp) handshake.buffer (::circt::handshake::BufferOp) handshake.conditional_branch (::circt::handshake::ConditionalBranchOp) handshake.constant (::circt::handshake::ConstantOp) handshake.control_merge (::circt::handshake::ControlMergeOp) handshake.end (::circt::handshake::EndOp) handshake.fork (::circt::handshake::ForkOp) handshake.func (::circt::handshake::FuncOp) handshake.instance (::circt::handshake::InstanceOp) handshake.join (::circt::handshake::JoinOp) handshake.lazy_fork (::circt::handshake::LazyForkOp) handshake.load (::circt::handshake::LoadOp) handshake.memory (::circt::handshake::MemoryOp) handshake.merge (::circt::handshake::MergeOp) handshake.mux (::circt::handshake::MuxOp) handshake.never (::circt::handshake::NeverOp) handshake.return (::circt::handshake::ReturnOp) handshake.sink (::circt::handshake::SinkOp) handshake.source (::circt::handshake::SourceOp) handshake.start (::circt::handshake::StartOp) handshake.store (::circt::handshake::StoreOp) handshake.terminator (::circt::handshake::TerminatorOp) This document also explains in a high-level manner how different components are organized, the principles behind them and the conventions we followed.</description></item><item><title>'llhd' Dialect</title><link>https://circt.llvm.org/docs/Dialects/LLHD/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/LLHD/</guid><description>A low-level hardware description dialect in MLIR.
Operation definition llhd.and (::circt::llhd::AndOp) llhd.array (::circt::llhd::ArrayOp) llhd.array_uniform (::circt::llhd::ArrayUniformOp) llhd.const (::circt::llhd::ConstOp) llhd.drv (::circt::llhd::DrvOp) llhd.dyn_extract_element (::circt::llhd::DynExtractElementOp) llhd.dyn_extract_slice (::circt::llhd::DynExtractSliceOp) llhd.entity (::circt::llhd::EntityOp) llhd.eq (::circt::llhd::EqOp) llhd.extract_element (::circt::llhd::ExtractElementOp) llhd.extract_slice (::circt::llhd::ExtractSliceOp) llhd.halt (::circt::llhd::HaltOp) llhd.insert_element (::circt::llhd::InsertElementOp) llhd.insert_slice (::circt::llhd::InsertSliceOp) llhd.inst (::circt::llhd::InstOp) llhd.load (::circt::llhd::LoadOp) llhd.neg (::circt::llhd::NegOp) llhd.neq (::circt::llhd::NeqOp) llhd.not (::circt::llhd::NotOp) llhd.or (::circt::llhd::OrOp) llhd.prb (::circt::llhd::PrbOp) llhd.proc (::circt::llhd::ProcOp) llhd.reg (::circt::llhd::RegOp) llhd.smod (::circt::llhd::SModOp) llhd.shl (::circt::llhd::ShlOp) llhd.shr (::circt::llhd::ShrOp) llhd.sig (::circt::llhd::SigOp) llhd.store (::circt::llhd::StoreOp) llhd.terminator (::circt::llhd::TerminatorOp) llhd.tuple (::circt::llhd::TupleOp) llhd.</description></item><item><title>'rtl' Dialect</title><link>https://circt.llvm.org/docs/Dialects/RTL/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/RTL/</guid><description>Types and operations for rtl dialect This dialect defines the rtl dialect, which is intended to be a generic representation of RTL outside of a particular use-case.
Type constraint definition fixed-sized array inout type RTL struct type SystemVerilog &amp;lsquo;unpacked&amp;rsquo; fixed-sized array Operation definition rtl.add (::circt::rtl::AddOp) rtl.and (::circt::rtl::AndOp) rtl.andr (::circt::rtl::AndROp) rtl.array_create (::circt::rtl::ArrayCreateOp) rtl.array_get (::circt::rtl::ArrayGetOp) rtl.array_slice (::circt::rtl::ArraySliceOp) rtl.bitcast (::circt::rtl::BitcastOp) Integer bit vectors Arrays Structs Example figure rtl.concat (::circt::rtl::ConcatOp) rtl.</description></item><item><title>'staticlogic' Dialect</title><link>https://circt.llvm.org/docs/Dialects/StaticLogic/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/StaticLogic/</guid><description>Operation definition staticlogic.pipeline (::circt::staticlogic::PipelineOp) staticlogic.return (::circt::staticlogic::ReturnOp) Operation definition staticlogic.pipeline (::circt::staticlogic::PipelineOp) pipeline operation
The &amp;ldquo;staticlogic.pipeline&amp;rdquo; operation represents a statically scheduled pipeline stucture which contains several MLIR blocks. Each MLIR block is corresponding to a pipeline stage.
Operands: Operand Description «unnamed» any type Results: Result Description «unnamed» any type staticlogic.</description></item><item><title>'sv' Dialect</title><link>https://circt.llvm.org/docs/Dialects/SV/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/SV/</guid><description>Types and operations for SV dialect This dialect defines the sv dialect, which represents various SystemVerilog-specific constructs in an AST-like representation.
Type constraint definition SystemVerilog interface type pointing to an InterfaceOp SystemVerilog type pointing to an InterfaceModportOp Operation definition sv.alias (::circt::sv::AliasOp) sv.alwaysff (::circt::sv::AlwaysFFOp) sv.always (::circt::sv::AlwaysOp) sv.array_index_inout (::circt::sv::ArrayIndexInOutOp) sv.assert (::circt::sv::AssertOp) sv.interface.signal.assign (::circt::sv::AssignInterfaceSignalOp) sv.assume (::circt::sv::AssumeOp) sv.bpassign (::circt::sv::BPAssignOp) sv.connect (::circt::sv::ConnectOp) sv.cover (::circt::sv::CoverOp) sv.fwrite (::circt::sv::FWriteOp) sv.fatal (::circt::sv::FatalOp) sv.finish (::circt::sv::FinishOp) sv.</description></item><item><title>CIRCT Charter</title><link>https://circt.llvm.org/docs/Charter/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Charter/</guid><description>Abstract Recent trends in computer architecture have resulted in two core problems. Firstly, how do we design complex, heterogenous systems-on-chip mixing general purpose and specialized components? Secondly, how do we program them? We believe that design tools that represent and manipulate a wide variety of abstractions are central to solving these problems. This projects is focused on using LLVM/MLIR to express these abstractions and to build useable open-source flows based on those abstractions to solve the design problems of the next decade.</description></item><item><title>ESI cosimulation model</title><link>https://circt.llvm.org/docs/ESI/cosim/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/ESI/cosim/</guid><description>Elastic Silicon Interfaces provides a feature called cosimulation. Cosim in general allows communication between the simulation and software. In the ESI case, it is typed and can be used to build an application and language specific API which is nearly identical to how the real hardware would interface. This allows users to simulate against the actual target software (or some simplification of it), enabling easier co-design.
ESI cosim uses Cap&amp;rsquo;nProto as a message format and RPC client/server.</description></item><item><title>FIRRTL Dialect Rationale</title><link>https://circt.llvm.org/docs/RationaleFIRRTL/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleFIRRTL/</guid><description>This document describes various design points of the FIRRTL dialect, why it is the way it is, and current status and progress. This follows in the spirit of other MLIR Rationale docs .
Introduction The FIRRTL project is an existing open source compiler infrastructure used by the Chisel framework to lower &amp;ldquo;.fir&amp;rdquo; files to Verilog. It provides a number of useful compiler passes and infrastructure that allows the development of domain specific passes.</description></item><item><title>handshake-runner</title><link>https://circt.llvm.org/docs/CommandGuide/handshake-runner/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/CommandGuide/handshake-runner/</guid><description>SYNOPSIS | handshake-runner [options] [filename] [arguments]
DESCRIPTION This application executes a function in the given MLIR module. Arguments to the function are passed on the command line and results are returned on stdout. Memref types are specified as a comma-separated list of values. This particular tool is use to check the validity of Standard-to-Handshake conversion in CIRCT.
Example The following MLIR module first convert to Handshake IR with the circt-opt tool as circt-opt -create-dataflow &amp;lt;file-name&amp;gt;.</description></item><item><title>Passes</title><link>https://circt.llvm.org/docs/Passes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Passes/</guid><description>This document describes the available CIRCT passes and their contracts.
Transformations Passes -llhd-early-code-motion: Move side-effect-free instructions and llhd.prb up in the CFG -llhd-function-elimination: Deletes all functions. -llhd-memory-to-block-argument: Promote memory to block arguments. -llhd-process-lowering: Lowers LLHD Processes to Entities. Conversion Passes -convert-firrtl-to-llhd: Convert FIRRTL to LLHD -convert-rtl-to-llhd: Convert RTL to LLHD -convert-llhd-to-llvm: Convert LLHD to LLVM -lower-firrtl-to-rtl: Lower FIRRTL to RTL -lower-firrtl-to-rtl-module: Lower FIRRTL to RTL Modules firrtl Dialect Passes -firrtl-lower-types: Lower FIRRTL types to ground types sv Dialect Passes Transformations Passes -llhd-early-code-motion: Move side-effect-free instructions and llhd.</description></item><item><title>RTL and SV Dialect Rationale</title><link>https://circt.llvm.org/docs/RationaleRTL-SV/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleRTL-SV/</guid><description>This document describes various design points of the RTL and SV dialects, why they are the way they are, and current status. This follows in the spirit of other MLIR Rationale docs .
Introduction SystemVerilog is an industry standard language for hardware design and verification, is known by a large number of engineers who write it directly, and is an important interchange format between EDA tools. However, while it is ubiquitous, SystemVerilog is not easy to generate or transform.</description></item></channel></rss>